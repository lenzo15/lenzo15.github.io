<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>迷宫生成算法</title>
      <link href="/posts/656349941/"/>
      <url>/posts/656349941/</url>
      
        <content type="html"><![CDATA[<p>迷宫生成算法可看作求一个每个边的权值相等的图的最小生成树。所以我们在<a href="/posts/2274644961/" title="最小生成树算法">最小生成树算法</a> 所提到的$Kruskal$算法和$Prim$算法都常用于随机迷宫生成，除此之外，DFS和递归分割算法等也是常用的迷宫生成算法，这里对这四种算法都进行介绍。</p><p>如果想自定义尝试可以去我的开源项目查看 <a href="https://github.com/lenzo15/PathFind-Visualizer">PathFind-Visualizer</a></p><p>介于有的迷宫生成算法会假定迷宫格子是紧密排布的，格子之间天然存在墙壁，而有的算法会将墙壁也视为一个格子，以下都统一将墙壁也视为个格子。</p><h2 id="DFS迷宫生成"><a href="#DFS迷宫生成" class="headerlink" title="DFS迷宫生成"></a>DFS迷宫生成</h2><p>随机 DFS 算法利用栈结构，通过每一步对图的边进行随机选择来生成随机的迷宫，其具体步骤伪代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将当前节点标记为“已访问”并压入栈</span><br><span class="line">while 栈中存在节点：</span><br><span class="line">    if 栈顶节点周围有其他的未访问邻接节点：</span><br><span class="line">        选择任一节点标记“已访问”并压入栈</span><br><span class="line">        打通原节点与该节点之间的墙</span><br><span class="line">    else：</span><br><span class="line">        将该节点出栈</span><br></pre></td></tr></table></figure></p><p>在项目PathFind-Visualizer中DFS的核心代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask <span class="title">DFSGenMaze</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    visitedCells = <span class="keyword">new</span> HashSet&lt;Cell&gt;();</span><br><span class="line">    <span class="keyword">var</span> firstCell = mazeCells[<span class="number">0</span>];</span><br><span class="line">    firstCell.SetCellType(CellType.Visited);</span><br><span class="line">    visitedCells.Add(firstCell);</span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;Cell&gt;();</span><br><span class="line">    Cell lastPopCell = <span class="literal">null</span>;</span><br><span class="line">    stack.Push(firstCell);</span><br><span class="line">    <span class="keyword">while</span> (stack.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> peekCell = stack.Peek();</span><br><span class="line">        <span class="keyword">var</span> neighborCell = GetRandomNeighbor(peekCell);</span><br><span class="line">        <span class="keyword">if</span> (neighborCell != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastPopCell != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> wall = GetBetweenCellsWall(lastPopCell, peekCell);</span><br><span class="line">                wall.SetCellType(CellType.Normal);</span><br><span class="line">            &#125;</span><br><span class="line">            neighborCell.SetCellType(CellType.Research);</span><br><span class="line">            <span class="keyword">var</span> betweenCellsWall = GetBetweenCellsWall(peekCell, neighborCell);</span><br><span class="line">            <span class="keyword">if</span> (betweenCellsWall != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                betweenCellsWall.SetCellType(CellType.Visited);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">await</span> UniTask.Delay(delayTime);</span><br><span class="line">            neighborCell.SetCellType(CellType.Visited);</span><br><span class="line">            visitedCells.Add(neighborCell);</span><br><span class="line">            stack.Push(neighborCell);</span><br><span class="line">            lastPopCell = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> popCell = stack.Pop();</span><br><span class="line">            popCell.SetCellType(CellType.Normal);</span><br><span class="line">            <span class="keyword">if</span> (lastPopCell != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> wall = GetBetweenCellsWall(lastPopCell, popCell);</span><br><span class="line">                wall.SetCellType(CellType.Normal);</span><br><span class="line">            &#125;</span><br><span class="line">            lastPopCell = popCell;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> UniTask.Delay(delayTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> UniTask.CompletedTask;</span><br><span class="line">    Debug.Log(<span class="string">&quot;DFSGenMaze done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>演示如下：<br><img src="/posts/656349941/DFS%E7%94%9F%E6%88%90%E8%BF%B7%E5%AE%AB.gif" class="" title="DFS生成迷宫"></p><h2 id="随机Kruskal迷宫生成"><a href="#随机Kruskal迷宫生成" class="headerlink" title="随机Kruskal迷宫生成"></a>随机Kruskal迷宫生成</h2><p>$Kruskal$是最小生成树算法中的著名算法之一，详细可见<a href="/posts/2274644961/#Kruskal%E7%AE%97%E6%B3%95" title="最小生成树算法">Kruskal最小生成树算法</a>。其核心要义是将所有的边按照从小到大排序，从最短边开始依次选择，将不连通的两个端点连接在一起，最后可以得到一个树结构，且其总边长度是所有可能生成树中最小的。</p><p>在迷宫生成中，由于所有边都是等权的，所以只需要随机选择任意一个可能的边，然后将它们连接在一起，即可。其具体步骤伪代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">生成所有边的列表，并为创建一个并查集包含所有初始迷宫节点</span><br><span class="line">while 边列表中存在元素：</span><br><span class="line">    选取边列表中随机一条边</span><br><span class="line">    if 这条边的两个端点属于不同的集合：</span><br><span class="line">        连接并合并两个节点</span><br><span class="line">    删除这条边</span><br></pre></td></tr></table></figure><br>在项目PathFind-Visualizer中的核心代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask <span class="title">KruskalGenMaze</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ufSet = <span class="keyword">new</span> UFSet(mazeCells.Count);</span><br><span class="line">    <span class="keyword">while</span> (edges.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> edge = edges[random.Next(<span class="number">0</span>, edges.Count)];</span><br><span class="line">        <span class="keyword">var</span> cell1Index = edge.cell1.y / <span class="number">2</span> * mazeCellWidth + edge.cell1.x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">var</span> cell2Index = edge.cell2.y / <span class="number">2</span> * mazeCellWidth + edge.cell2.x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ufSet.Find(cell1Index) != ufSet.Find(cell2Index))</span><br><span class="line">        &#123;</span><br><span class="line">            ufSet.Union(cell1Index, cell2Index);</span><br><span class="line">            edge.wall.SetCellType(CellType.Normal);</span><br><span class="line">            edges.Remove(edge);</span><br><span class="line">            <span class="keyword">await</span> UniTask.Delay(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            edges.Remove(edge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> UniTask.CompletedTask;</span><br><span class="line">    Debug.Log(<span class="string">&quot;KruskalGenMaze done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>演示如下：<br><img src="/posts/656349941/Kruskal%E7%94%9F%E6%88%90%E8%BF%B7%E5%AE%AB.gif" class="" title="Kruskal生成迷宫"></p><p>需要注意的是，在这个基础实现中，每个九宫格中心的墙体由于初始时未被添加到边列表中，因此会永久保留，不会因为连接相邻节点而被移除。如果需要打通这些中心墙体，则需要在每次移除墙体时动态维护边列表，将新产生的边及时添加进去。此处仅作概念说明，不再进行具体实现。</p><h2 id="随机Prim迷宫生成"><a href="#随机Prim迷宫生成" class="headerlink" title="随机Prim迷宫生成"></a>随机Prim迷宫生成</h2><p>$Prim$也是最小生成树算法中的著名算法之一，详细可见<a href="/posts/2274644961/#Prim%E7%AE%97%E6%B3%95" title="最小生成树算法">Prim最小生成树算法</a>。<br>其具体步骤伪代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">选一个节点，作为迷宫的初始通路，然后把它相邻的墙放入墙列表</span><br><span class="line">while 墙列表中还存在元素：</span><br><span class="line">    从列表中随机选择一个墙</span><br><span class="line">    if 墙对面的节点不是迷宫通路：</span><br><span class="line">        将对面的节点加入迷宫通路中</span><br><span class="line">    从列表中移除选择的墙</span><br></pre></td></tr></table></figure><br>在项目PathFind-Visualizer中的核心代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask <span class="title">PrimGenMaze</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    HashSet&lt;Cell&gt; visitedCells = <span class="keyword">new</span> HashSet&lt;Cell&gt;();</span><br><span class="line">    <span class="keyword">var</span> firstCell = mazeCells[<span class="number">0</span>];</span><br><span class="line">    firstCell.SetCellType(CellType.Visited);</span><br><span class="line">    visitedCells.Add(firstCell);</span><br><span class="line">    <span class="keyword">var</span> wallList = <span class="keyword">new</span> List&lt;WallWithOtherCell&gt;();</span><br><span class="line">    AddNeighborWall(firstCell, wallList);</span><br><span class="line">    <span class="keyword">while</span> (wallList.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> currentCell = wallList[random.Next(<span class="number">0</span>, wallList.Count)];</span><br><span class="line">        <span class="keyword">if</span> (!visitedCells.Contains(currentCell.otherCell))</span><br><span class="line">        &#123;</span><br><span class="line">            currentCell.wall.SetCellType(CellType.Visited);</span><br><span class="line">            currentCell.otherCell.SetCellType(CellType.Visited);</span><br><span class="line">            visitedCells.Add(currentCell.otherCell);</span><br><span class="line">            visitedCells.Add(currentCell.wall);</span><br><span class="line">            AddNeighborWall(currentCell.otherCell, wallList);</span><br><span class="line">            <span class="keyword">await</span> UniTask.Delay(delayTime);</span><br><span class="line">        &#125;</span><br><span class="line">        wallList.Remove(currentCell);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> cell <span class="keyword">in</span> visitedCells)</span><br><span class="line">    &#123;</span><br><span class="line">        cell.SetCellType(CellType.Normal);</span><br><span class="line">        <span class="keyword">await</span> UniTask.Delay(delayTime / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> UniTask.CompletedTask;</span><br><span class="line">    Debug.Log(<span class="string">&quot;PrimGenMaze done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>演示如下：<br><img src="/posts/656349941/Prim%E7%94%9F%E6%88%90%E8%BF%B7%E5%AE%AB.gif" class="" title="Prim生成迷宫"></p><h2 id="递归分割迷宫生成"><a href="#递归分割迷宫生成" class="headerlink" title="递归分割迷宫生成"></a>递归分割迷宫生成</h2><p>递归分割算法是一种基于分治思想的迷宫生成方法，通过”建墙”的方式来构造迷宫。算法的核心思想是：在当前处理的矩形区域内随机选择一个点作为分割中心，然后以该点为中心向上下左右四个方向各建一堵墙，将矩形分割成四个子区域。为了保证迷宫的连通性，这四堵墙中必须有三堵墙预留通道，否则会产生无法到达的孤立区域。对分割后的四个子矩形递归执行相同的过程，最终生成完整的迷宫结构。<br>其具体步骤伪代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def 递归分割迷宫生成(矩形区域):</span><br><span class="line">    if 矩形区域足够大可以分割:</span><br><span class="line">        在矩形区域内随机选择一个分割点</span><br><span class="line">        以分割点为中心，向上下左右四个方向各建一堵墙</span><br><span class="line">        随机选择三堵墙，在每堵墙上随机位置开一个通道</span><br><span class="line">        将矩形分割成四个子区域</span><br><span class="line">        对每个子区域递归调用 递归分割迷宫生成()</span><br><span class="line">    else:</span><br><span class="line">        返回  // 区域太小，无法继续分割</span><br></pre></td></tr></table></figure></p><p>在项目PathFind-Visualizer中的核心代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保证传入的width和height都是奇数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask <span class="title">RecursiveDivision</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (width &lt; <span class="number">3</span> || height &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> xIndex = (random.Next(<span class="number">1</span>, (width - <span class="number">1</span>) / <span class="number">2</span>) * <span class="number">2</span>) - <span class="number">1</span> + x;</span><br><span class="line">    <span class="comment">// var temp = </span></span><br><span class="line">    <span class="keyword">var</span> yIndex = (random.Next(<span class="number">1</span>, (height - <span class="number">1</span>) / <span class="number">2</span>) * <span class="number">2</span>) - <span class="number">1</span> + y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = x; i &lt; x + width; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = y; j &lt; y + height; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == xIndex || j == yIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                cellList[i + j * StrategyManager.Instance.width].SetCellType(CellType.Wall);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 横纵向随机选择三个门</span></span><br><span class="line">    <span class="keyword">var</span> choice = random.Next(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// var choice = 0;</span></span><br><span class="line">    <span class="keyword">if</span> (choice &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 横向</span></span><br><span class="line">        <span class="keyword">var</span> xDoor1 = random.Next(x / <span class="number">2</span>, (xIndex - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">var</span> xDoor2 = random.Next((xIndex + <span class="number">1</span>) / <span class="number">2</span>, (x + width - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        cellList[xDoor1 + yIndex * StrategyManager.Instance.width].SetCellType(CellType.Normal);</span><br><span class="line">        cellList[xDoor2 + yIndex * StrategyManager.Instance.width].SetCellType(CellType.Normal);</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> yDoor1 = random.Next(y / <span class="number">2</span>, (yIndex - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">            cellList[xIndex + yDoor1 * StrategyManager.Instance.width].SetCellType(CellType.Normal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> yDoor2 = random.Next((yIndex + <span class="number">1</span>) / <span class="number">2</span>, (y + height - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">            cellList[xIndex + yDoor2 * StrategyManager.Instance.width].SetCellType(CellType.Normal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 纵向</span></span><br><span class="line">        <span class="keyword">var</span> yDoor1 = random.Next(y / <span class="number">2</span>, (yIndex - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">var</span> yDoor2 = random.Next((yIndex + <span class="number">1</span>) / <span class="number">2</span>, (y + height - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        cellList[xIndex + yDoor1 * StrategyManager.Instance.width].SetCellType(CellType.Normal);</span><br><span class="line">        cellList[xIndex + yDoor2 * StrategyManager.Instance.width].SetCellType(CellType.Normal);</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> xDoor1 = random.Next(x / <span class="number">2</span>, (xIndex - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">            cellList[xDoor1 + yIndex * StrategyManager.Instance.width].SetCellType(CellType.Normal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> xDoor2 = random.Next((xIndex + <span class="number">1</span>) / <span class="number">2</span>, (x + width - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">            cellList[xDoor2 + yIndex * StrategyManager.Instance.width].SetCellType(CellType.Normal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> UniTask.Delay(delayTime);</span><br><span class="line">    <span class="keyword">await</span> RecursiveDivision(x, y, xIndex - x, yIndex - y);</span><br><span class="line">    <span class="keyword">await</span> RecursiveDivision(xIndex + <span class="number">1</span>, y, x + width - xIndex - <span class="number">1</span>, yIndex - y);</span><br><span class="line">    <span class="keyword">await</span> RecursiveDivision(x, yIndex + <span class="number">1</span>, xIndex - x, y + height - yIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> RecursiveDivision(xIndex + <span class="number">1</span>, yIndex + <span class="number">1</span>, x + width - xIndex - <span class="number">1</span>, y + height - yIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>演示如下：</p><img src="/posts/656349941/%E9%80%92%E5%BD%92%E5%88%86%E5%89%B2%E7%94%9F%E6%88%90%E8%BF%B7%E5%AE%AB.gif" class="" title="递归分割生成迷宫">]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua热重载实现与应用</title>
      <link href="/posts/3831755233/"/>
      <url>/posts/3831755233/</url>
      
        <content type="html"><![CDATA[<p>Lua热重载指在游戏运行的时候，修改Lua代码可以直接反应在游戏中，不需要在unity中重启游戏。</p><h2 id="原理与实现"><a href="#原理与实现" class="headerlink" title="原理与实现"></a>原理与实现</h2><p>Lua热重载的实现主要需要两步。</p><ol><li>监控Lua代码的修改</li><li>Lua代码的重加载</li></ol><h2 id="监控Lua代码的修改"><a href="#监控Lua代码的修改" class="headerlink" title="监控Lua代码的修改"></a>监控Lua代码的修改</h2><p>使用C# System.IO中的<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.io.filesystemwatcher">FileSystemWatcher</a>侦听Lua代码文件系统更改，并引发更改事件。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">ReloadDelegate</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaFileWatcher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReloadDelegate ReloadFunction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;<span class="built_in">string</span>&gt; m_pChangedFiles = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    [<span class="meta">RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnRuntimeInitialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pChangedFiles = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateLuaFileWatcher</span>(<span class="params">LuaEnv luaEnv</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pChangedFiles.Clear();</span><br><span class="line">        <span class="keyword">var</span> scriptPath = LUA_SCRIPT_PATH;</span><br><span class="line">        <span class="keyword">var</span> directoryWatcher = <span class="keyword">new</span> DirectoryWatcher(scriptPath, <span class="keyword">new</span> FileSystemEventHandler(LuaFileOnChanged));</span><br><span class="line">        ReloadFunction = luaEnv.Global.Get&lt;ReloadDelegate&gt;(<span class="string">&quot;Hotfix&quot;</span>);</span><br><span class="line">        EditorApplication.update -= Reload;</span><br><span class="line">        EditorApplication.update += Reload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LuaFileOnChanged</span>(<span class="params"><span class="built_in">object</span> obj, FileSystemEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> fullPath = <span class="keyword">args</span>.FullPath;</span><br><span class="line">        requirePath = Handle(fullPath);</span><br><span class="line">        m_pChangedFiles.Add(requirePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reload</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (EditorApplication.isPlaying == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_pChangedFiles.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_pChangedFiles.Count &gt; <span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pChangedFiles.Clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">file</span> <span class="keyword">in</span> m_pChangedFiles)</span><br><span class="line">            &#123;</span><br><span class="line">                ReloadFunction(<span class="keyword">file</span>);</span><br><span class="line">                XDebug.Log(<span class="string">&quot;Reload:&quot;</span> + <span class="keyword">file</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            m_pChangedFiles.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            XDebug.Log(<span class="string">$&quot;LuaFileWatcher ReloadFunction Fail <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">            m_pChangedFiles.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateWatch</span>(<span class="params"><span class="built_in">string</span> dirPath, FileSystemEventHandler handler</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(dirPath)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> watcher = <span class="keyword">new</span> FileSystemWatcher();</span><br><span class="line">    watcher.IncludeSubdirectories = <span class="literal">true</span>; ;</span><br><span class="line">    watcher.Path = dirPath;</span><br><span class="line">    watcher.NotifyFilter = NotifyFilters.LastWrite;</span><br><span class="line">    watcher.Filter = <span class="string">&quot;*.lua&quot;</span>;</span><br><span class="line">    watcher.Changed += handler;</span><br><span class="line">    watcher.EnableRaisingEvents = <span class="literal">true</span>;</span><br><span class="line">    watcher.InternalBufferSize = <span class="number">10240</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同时注册一个文件修改的触发函数，指向Lua代码中的Hotfix文件，由Lua来进行模块重载。</p><h2 id="Lua代码的重加载"><a href="#Lua代码的重加载" class="headerlink" title="Lua代码的重加载"></a>Lua代码的重加载</h2><p>Lua代码的热重载分四部分</p><ol><li>数据重载：数据需要保留原模块的数据。</li><li>函数重载：将新模块的函数替换掉旧模块的函数，与之同时，可能需要替换相应的上值，本实现中考虑到可能有表在模块中以上值的形式出现并被修改，为了兼容对上值的修改重载，没有进行函数上值的替换。</li><li>表重载：表实际上是一个嵌套的子模块，只需递归重载相应的数据、函数即可。</li><li>元表重载：可能会出现元表被修改需要重载的情况，所以也需对元表进行递归重载相应的数据、函数。</li></ol><p>具体实现代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 热重载主函数：重新加载指定的Lua模块并保持状态</span></span><br><span class="line"><span class="comment">-- @param filename 要热重载的模块名（不包含.lua扩展名）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hotfix</span><span class="params">(filename)</span></span></span><br><span class="line">    <span class="comment">-- 防止热重载自身，避免无限递归</span></span><br><span class="line">    <span class="keyword">if</span> filename == <span class="string">&quot;Hotfix&quot;</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    _Log(_DEBUG, _LogCheck(_DEBUG) <span class="keyword">or</span> <span class="string">&quot;start hotfix: &quot;</span>..filename,_LOG_GREEN)</span><br><span class="line">    <span class="keyword">local</span> oldModule</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 检查模块是否已经加载过</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">package</span>.<span class="built_in">loaded</span>[filename] <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 保存旧模块的引用，用于后续状态迁移</span></span><br><span class="line">        oldModule = <span class="built_in">package</span>.<span class="built_in">loaded</span>[filename]</span><br><span class="line">        <span class="comment">-- 从已加载模块表中移除，强制重新加载</span></span><br><span class="line">        <span class="built_in">package</span>.<span class="built_in">loaded</span>[filename] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _Log(_DEBUG, _LogCheck(_DEBUG) <span class="keyword">or</span> <span class="string">&quot;this file never loaded: &quot;</span>..filename,_LOG_YELLOW)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 尝试重新加载模块</span></span><br><span class="line">    <span class="keyword">local</span> ok,err = <span class="built_in">pcall</span>(<span class="built_in">require</span>, filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 如果重新加载失败，恢复旧模块</span></span><br><span class="line">        <span class="built_in">package</span>.<span class="built_in">loaded</span>[filename] = oldModule</span><br><span class="line">        _Log(_ERROR, _LogCheck(_ERROR) <span class="keyword">or</span> <span class="string">&quot;reload lua file failed.&quot;</span>,_LOG_RED)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 获取新加载的模块</span></span><br><span class="line">    <span class="keyword">local</span> newModule = <span class="built_in">package</span>.<span class="built_in">loaded</span>[filename]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 用于跟踪已更新的表，防止循环引用</span></span><br><span class="line">    <span class="keyword">local</span> tbUpdatedTables = &#123;&#125;</span><br><span class="line">    <span class="comment">-- 将新模块的内容更新到旧模块中，保持旧模块的引用</span></span><br><span class="line">    UpdateTable(newModule, oldModule,tbUpdatedTables)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果旧模块有OnReload回调，执行它</span></span><br><span class="line">    <span class="keyword">if</span> oldModule.OnReload ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        oldModule:OnReload()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    _Log(_DEBUG, _LogCheck(_DEBUG) <span class="keyword">or</span> <span class="string">&quot;replaced succeed&quot;</span>,_LOG_GREEN)</span><br><span class="line">    <span class="comment">-- 将更新后的旧模块重新设置为已加载模块</span></span><br><span class="line">    <span class="built_in">package</span>.<span class="built_in">loaded</span>[filename] = oldModule</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数上值更新函数：将旧函数的上值复制到新函数中</span></span><br><span class="line"><span class="comment">-- 注意：目前此功能被禁用，因为上值复制可能导致热重载失败</span></span><br><span class="line"><span class="comment">-- 建议：项目中上值最好不要是可写的，否则可能导致热重载失败</span></span><br><span class="line"><span class="comment">-- @param tbNewFunc 新函数</span></span><br><span class="line"><span class="comment">-- @param tbOldFunc 旧函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UpdateFunc</span><span class="params">(tbNewFunc, tbOldFunc)</span></span></span><br><span class="line">    <span class="comment">-- 确保新函数是函数类型</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="string">&quot;function&quot;</span> == <span class="built_in">type</span>(tbNewFunc))</span><br><span class="line">    <span class="comment">-- 确保旧函数是函数类型或nil</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="string">&quot;function&quot;</span> == <span class="built_in">type</span>(tbOldFunc) <span class="keyword">or</span> tbOldFunc == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果旧函数不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> tbOldFunc == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 获取旧函数的所有上值，建立映射表</span></span><br><span class="line">    <span class="keyword">local</span> tbOldUpvalueMap = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> name, value = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(tbOldFunc, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        tbOldUpvalueMap[name] = value</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 将旧函数的上值设置到新函数中</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> name, value = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(tbNewFunc, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- 跳过特殊的上值名称（环境变量、类、父类等）</span></span><br><span class="line">        <span class="keyword">if</span> name ~= <span class="string">&quot;_ENV&quot;</span> <span class="keyword">and</span> name ~= <span class="string">&quot;cls&quot;</span> <span class="keyword">and</span> name ~= <span class="string">&quot;super&quot;</span> <span class="keyword">then</span></span><br><span class="line">            _Log(_DEBUG, _LogCheck(_DEBUG) <span class="keyword">or</span> <span class="string">&quot;set up value: name:&quot;</span>..name,_LOG_GREEN)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">-- 如果旧函数中有同名上值，则用旧值替换新值</span></span><br><span class="line">        <span class="keyword">local</span> oldValue = tbOldUpvalueMap[name]</span><br><span class="line">        <span class="keyword">if</span> oldValue <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">debug</span>.<span class="built_in">setupvalue</span>(tbNewFunc, i, oldValue)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表更新函数：递归地将新表的内容更新到旧表中，保持旧表的引用不变</span></span><br><span class="line"><span class="comment">-- @param tbNewTable 新表（源表）</span></span><br><span class="line"><span class="comment">-- @param tbOldTable 旧表（目标表）</span></span><br><span class="line"><span class="comment">-- @param tbUpdatedTables 已更新表的跟踪表，防止循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UpdateTable</span><span class="params">(tbNewTable, tbOldTable, tbUpdatedTables)</span></span></span><br><span class="line">    <span class="comment">-- 确保两个参数都是表类型</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="string">&quot;table&quot;</span> == <span class="built_in">type</span>(tbNewTable))</span><br><span class="line">    <span class="built_in">assert</span>(<span class="string">&quot;table&quot;</span> == <span class="built_in">type</span>(tbOldTable))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 遍历新表的所有键值对，更新到旧表中</span></span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(tbNewTable) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> oldValue = tbOldTable[key]</span><br><span class="line">        <span class="keyword">local</span> typeValue = <span class="built_in">type</span>(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> typeValue == <span class="string">&quot;function&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 直接替换函数，不复制上值（避免状态丢失）</span></span><br><span class="line">            <span class="comment">-- 注意：这里禁用了上值复制，如果需要复制上值可以启用下面的函数</span></span><br><span class="line">            <span class="comment">-- UpdateFunc(value, oldValue)</span></span><br><span class="line">            tbOldTable[key] = value</span><br><span class="line">        <span class="keyword">elseif</span> typeValue == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 递归更新子表，但需要检查是否已经更新过（防止循环引用）</span></span><br><span class="line">            <span class="keyword">if</span> ( tbUpdatedTables[value] == <span class="literal">nil</span> ) <span class="keyword">then</span></span><br><span class="line">                tbUpdatedTables[value] = <span class="literal">true</span></span><br><span class="line">                UpdateTable(value, oldValue, tbUpdatedTables)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">-- 对于其他类型（number, string, boolean等），直接复制</span></span><br><span class="line">            tbOldTable[key] = value</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 更新元表：如果两个表都有元表，则递归更新元表</span></span><br><span class="line">    <span class="keyword">local</span> tbOldMeta = <span class="built_in">debug</span>.<span class="built_in">getmetatable</span>(tbOldTable)</span><br><span class="line">    <span class="keyword">local</span> tbNewMeta = <span class="built_in">debug</span>.<span class="built_in">getmetatable</span>(tbNewTable)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tbOldMeta) == <span class="string">&quot;table&quot;</span> <span class="keyword">and</span> <span class="built_in">type</span>(tbNewMeta) == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">        UpdateTable(tbNewMeta, tbOldMeta, tbUpdatedTables)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="什么是Lua的上值-Upvalue"><a href="#什么是Lua的上值-Upvalue" class="headerlink" title="什么是Lua的上值(Upvalue)"></a>什么是Lua的上值(Upvalue)</h3><p>Lua官方对于上值的解释是：</p><blockquote><p>注册表提供了全局变量，而上值（upvalue）则实现了一种类似于C语言静态变量（只在特定的函数中可见）的机制。每一次在Lua中创建新的C函数时，都可以将任意数量的上值与这个函数相关联，而每个上值都可以保存一个Lua值。后面在调用该函数时，可以通过伪索引来自由地访问这些上值。我们将这种C函数与其上值的关联称为闭包（closure）​。C语言闭包类似于Lua语言闭包。特别的，可以用相同的函数代码来创建不同的闭包，每个闭包可以拥有不同的上值。</p></blockquote><p>举一个简单的例子，对于下面的代码<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> upval = <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> upval2 = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> locvar = <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(upval)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">localTest</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(upval+upval2+locvar)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    localTest()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>在上面这个例子中，test函数的外层，一共有两个变量，upval和upval2。test函数内，有一行打印upval的代码，因为有这个操作，test函数需要引用到外层函数的upval这个变量，因此upval是test函数的一个upvavle。而上面这个例子，在test函数内，又定义了一个localTest函数，在localTest函数内，因为使用了upval、upval2和locvar几个变量，因此localTest函数的upvalue有upval、upval2和locvar。由于localTest是test的内层定义的函数，test是localTest的外层函数，因此test函数的upvalue也包括了，upval、upval2。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热重载 </tag>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通信（八）网络同步预表现技术</title>
      <link href="/posts/2434505821/"/>
      <url>/posts/2434505821/</url>
      
        <content type="html"><![CDATA[<h2 id="网络游戏的客户端预表现技术"><a href="#网络游戏的客户端预表现技术" class="headerlink" title="网络游戏的客户端预表现技术"></a>网络游戏的客户端预表现技术</h2><p>绝大多数的网络游戏，总会将服务器作为各客户端间交互通信的权威中转站和裁决者，玩家的操作指令总要经过服务器的中转，直到接收到服务器的下行数据后才能真正执行游戏逻辑、更新画面表现。这段网络通信的时间，导致从玩家发起操作到看到画面展示出相应的操作表现之间存在一段显示延迟。显示延迟超过一定阈值后，玩家的操作将不能得到即时的表现反馈，会有明显的延迟感受。<br>为了优化高延迟网络下的游戏操作和表现延迟，客户端预表现技术应运而生。其主要策略是：在游戏操作发出时，由客户端在本地立即处理，先行执行和展示一些画面表现，而不必等到服务器确认下发。这样，在玩家按键操作的同时，游戏画面就能立即更新、展现部分操作表现反馈，玩家的操作手感得到明显提升。<br>以下介绍一些常用或者著名的预表现方案。<br><span id="more"></span></p><h2 id="客户端预测回滚"><a href="#客户端预测回滚" class="headerlink" title="客户端预测回滚"></a>客户端预测回滚</h2><p>客户端预测回滚是相当普遍常用的客户端表现技术。<br>首先客户端先行，玩家输入（如按下前进键）后，客户端立即模拟操作结果（角色移动），无需等待服务器确认，以消除操作延迟。这就是客户端预测的部分。<br>在服务器回包后，对比当前客户端预测，发现状态不一致的情况。这时则需要进行回滚。<br>这时，客户端会回滚到状态不一致的那一帧，然后再重新应用这一帧之后的所有指令，此为最新的预测状态，之后再通过插值平滑的过渡到此状态。<br>在许多游戏中我们常常会遇到的，当自己网络不好时会出现自己向某个方向移动了一段距离后，突然被拉回到一段时间之前的位置上。这就是发生了客户端预测和服务器回包权威数据不一致的情况，导致了明显的客户端回滚。</p><h3 id="实现重点"><a href="#实现重点" class="headerlink" title="实现重点"></a>实现重点</h3><p>要实现客户端预测回滚，除了需要在客户端本地实现和服务器一样的游戏玩法逻辑外，客户端还需要对需要进行预测回滚的游戏物体历史状态进行快照保存。<br>需要注意的一点，这里说的是对需要进行预测回滚的游戏物体，对于敌人血量，敌人是否死亡之类的对游戏逻辑有重大影响的游戏状态，则不应该进行客户端预测，应该都使用服务器权威数据（不然会出现敌人死了又活了的奇怪现象……）。<br>快照可以按帧保存，也可以按变化节点进行保存等，这取决于具体的项目实现。这里还需要注意的是，客户端预测不是无限时间上的预测，记录的历史状态也应该是从当前时间到过去一段时间内的数据，当超过一定的时间，说明客户端网络相当不好，客户端应该执行断线重连等操作。<br>在我们执行服务器回包数据和客户端预测数据校验时，可以使用Hash值来加速校验。<br>除了对玩家自己进行预测外，对于该玩家视角下的其他玩家，也可以进行预测。比如让其他玩家按最后一次收到的服务器速度继续前进，按旋转角速度进行旋转预测等。在后面会讲到，这种做法又叫外推法或导航预测。</p><h2 id="游戏对象显示"><a href="#游戏对象显示" class="headerlink" title="游戏对象显示"></a>游戏对象显示</h2><p>（以下是V社发布的《半条命》游戏中的游戏对象显示的翻译）</p><p>确定游戏对象显示位置的两种最基本方法是外推法和插值法。</p><p>采用外推法时，系统会基于最后已知的位置、方向和速度，以近似弹道式的方式对其他玩家/对象进行时间上的向前模拟。例如，若存在100毫秒延迟，且最后接收到的更新显示其他玩家正以每秒500单位的速度垂直于你的视角移动，客户端便可推定该玩家在”实时”状态下已从最后已知位置直线前进了50个单位。随后，客户端只需将玩家绘制在这个外推位置，本地玩家仍可大致准确瞄准对方。<br>外推法的最大缺陷在于玩家的移动并不符合弹道规律，反而具有高度不确定性和剧烈变化性。加之多数FPS游戏采用非真实的玩家物理模型——玩家可瞬时转向并施加不合理力场以产生任意角度的大幅加速——这使得外推结果经常出错。开发者可通过将外推时间限制在合理值范围内来减小误差（例如《雷神之锤》将外推时间限定为100毫秒）。这种限制能有效控制当真实玩家位置最终被接收时所需的修正幅度。在大多数玩家仍面临超过150毫秒延迟的环境中，用户仍需预判其他玩家的移动轨迹才能命中目标。若因外推误差导致玩家位置频繁”跳变”，游戏体验仍会受损。<br>另一种确定对象和玩家显示位置的方法是插值法。插值可视为始终让对象相对于最新接收到的有效位置保持一定时间延迟的移动方式。例如，若服务器每秒精确发送10次世界状态更新，我们可在渲染时施加100毫秒的插值延迟。在渲染帧时，我们会在100毫秒内将对象位置在上次更新位置与前次更新位置（或上次渲染位置）之间进行插值计算。当对象刚好到达最新更新位置时，由于每秒10次更新意味着每100毫秒收到一次新数据，我们便可开始朝着新的位置进行下一个100毫秒的移动。<br>若某个更新数据包未能到达，系统面临两种选择：可以启动上述外推法计算玩家位置（但存在显著误差风险），或直接让玩家停留在最后更新位置直至新数据到达（但这会导致移动卡顿）。<br>此类插值法的通用算法如下：</p><ol><li>每个更新数据包包含其生成时的服务器时间戳</li><li>客户端根据当前时间减去插值时间差（100毫秒）计算出目标时间</li><li>若目标时间介于最近两次更新的时间戳之间，则根据时间间隔占比计算插值系数</li><li>该系数用于对所有需插值参数（如位置与角度）进行插值计算</li></ol><p>本质上，在上述示例中，可以将插值法理解为在客户端上额外缓冲100毫秒的数据。因此，其他玩家的绘制位置实际上等于其过去某个时间点的状态，该时间点对应玩家的精确延迟加上插值所覆盖的时间段。为应对偶发性丢包，我们可以将插值时间设置为200毫秒而非100毫秒。这样（再次假设服务器每秒发送10次更新）即使完全错过一次更新，玩家仍能向有效位置进行插值移动，通常可顺畅完成整个插值过程。当然，增加插值时间是一种权衡策略，它是以增加延迟（使被插值玩家更难以被命中）为代价来换取视觉流畅度。<br>此外，上述插值方法（客户端仅追踪最近两次更新并始终向最新更新位置直接移动）要求服务器更新必须保持固定时间间隔。该方法还存在难以解决的视觉质量问题。具体表现为：假设被插值对象是一个弹跳的球体（这实际上准确描述了某些玩家的运动状态）。在运动极限位置，球体要么处于空中高点，要么接触地面。但平均而言，球体通常处于中间位置。若我们仅插值到最后记录的位置，该位置极有可能既不在地面也不在最高点。球的弹跳运动因此被”压平”，永远无法呈现触地的瞬间。这是典型的采样频率问题，可通过增加世界状态采样频率来缓解。但即便如此，我们仍然很难使插值目标状态恰好位于地面或最高点，位置扁平化问题依然存在。<br>另外，由于不同用户拥有不同的网络连接条件，强制以固定频率（如每秒10次）进行更新无异于将最低标准强加给所有用户。《半条命》允许用户根据需求自定义每秒更新次数（在合理范围内）。因此，网络连接顺畅的用户最高可设定每秒接收50次更新。默认情况下，《半条命》每秒向每位玩家发送20次更新，客户端以100毫秒为周期对玩家（及许多其他对象）进行插值计算。<br>为解决弹跳球体运动轨迹被压平的问题，我们采用了一种不同的插值算法。该方法为每个需要插值的对象维护更完整的”位置历史记录”。位置历史记录包含对象的时间戳、坐标原点、角度（以及任何其他需要插值的数据）。每次从服务器接收更新时都会创建新的历史记录条目，包含该时间戳对应的坐标和角度。进行插值时，我们按前述方法计算目标时间，随后在位置历史记录中反向搜索跨越目标时间的一对更新数据，据此插值计算出该帧的最终位置。这种方法使我们能够平滑地遵循完全包含所有采样点的曲线轨迹。当客户端运行帧率高于服务器更新速率时，几乎可以确保在采样点之间实现平滑移动，从而最大限度减轻（当然无法完全消除，因为世界状态的采样速率仍是限制因素）上述轨迹扁平化问题。<br>在实施任何插值方案时，我们还需要额外考虑如何判定对象属于强制传送而非快速移动。否则系统可能将长距离传送”平滑”处理为极速移动，导致对象移动表现失真。我们既可以在更新数据中设置”禁止插值”或”清空位置历史”的标识位，也可以通过判断两次更新间坐标距离是否超出阈值来推定是否发生传送/跃迁。此类情况下，解决方案通常是直接将对象置于最新已知位置并从此点开始重新插值。</p><h2 id="导航预测"><a href="#导航预测" class="headerlink" title="导航预测"></a>导航预测</h2><p>导航预测（Dead Reckoning）本来是用于无人机、自动驾驶汽车的位置预测技术，也可以用于游戏中玩家位置的更新，是上述外推法的拓展技术。Dead Reckoning算法是一种基于已知速度和方向来计算移动距离和位置的算法。其基本算法即：</p><ol><li>通过速度和时间线性推算目标点。</li><li>通过速度、加速度和时间的二次函数推算目标点。</li></ol><p>当导航预测的目标点A和服务器发送的点位B不一致时该如何处理呢？下面提供4种方法：</p><h3 id="跳变法"><a href="#跳变法" class="headerlink" title="跳变法"></a>跳变法</h3><p>直接将物体从A点更新到B点，这会产生明显跳变。</p><h3 id="线性平滑法"><a href="#线性平滑法" class="headerlink" title="线性平滑法"></a>线性平滑法</h3><ol><li>计算过渡时间：<script type="math/tex; mode=display">T=\frac{Dis(P_0,P_{aim})}{v_{new}}​</script></li><li>计算时间T后的预期位置：<script type="math/tex; mode=display">P_E=P_{aim}+v_{new}T+\frac{1}{2}a_{new}T</script></li><li><p>计算修正速度:</p><script type="math/tex; mode=display">v_{adj}=\frac{Dis(P_E,P_0)}{T}</script><p>通过上述三步来实现在时间$T$内，将目标物体移动到期望位置，时间$T$后，将速度、加速度等信息恢复到服务器下发的数据。</p><h3 id="二次平滑法"><a href="#二次平滑法" class="headerlink" title="二次平滑法"></a>二次平滑法</h3><p>线性平滑法常常出现明显的拐点，为了尽量消除这种拐点而产生了该方法，其核心思想是通过二次曲线（抛物线）而非直线来连接当前位置与目标位置，使移动轨迹更符合自然物体的运动特性。其会在线性平滑的基础上，通过构造二次曲线来修正位置信息（而不是通过速度×时间来修正）。$f(t) = at^2+bt+c$ 其中系数$a$、$b$、$c$通过以下边界条件确定：</p></li></ol><ul><li>当t=0时，f(0)=当前位置</li><li>当t=T时，f(T)=预期位置</li><li>当t=0时，f’(0)=当前速度（确保速度连续）<h3 id="样条曲线插值法"><a href="#样条曲线插值法" class="headerlink" title="样条曲线插值法"></a>样条曲线插值法</h3>样条曲线的核心思想是​​利用多个历史数据点来共同定义一条平滑的路径​​，而不仅仅是依赖最新的一个点。这就像用多个点来固定一根富有弹性的木条（样条），使其弯曲成一条光滑的曲线。这里介绍​​Hermite样条​​，其他还有Catmull-Rom样条等，原理其实类似。<h4 id="​​Hermite样条​​"><a href="#​​Hermite样条​​" class="headerlink" title="​​Hermite样条​​"></a>​​Hermite样条​​</h4>​​原理​​：不仅需要两个点$(P_0, P_1)$的位置，还需要这两个点的​​切线方向$​​(R_0, R_1)$，通常由速度向量推导而来。通过这四个参数，可以唯一确定一条连接两点的三次多项式曲线，并保证在起点和终点处的方向和速度是连续的。<img src="/posts/2434505821/Hermite%E6%A0%B7%E6%9D%A1.png" class="" title="Hermite样条"></li></ul><p>​​在游戏中的应用​​：当收到一个新的服务器回包时，客户端拥有：</p><ol><li>​​上一个已知位置点 $P_0$​​（及其速度/切线 $R_0$）</li><li>​​最新收到的位置点 $P_1$​​（及其速度/切线 $R_1$）</li></ol><p>利用这四个值构建Hermite样条，物体从$P_0$到$P_1$的移动将严格遵循这条曲线。由于曲线在$P_0$和$P_1$点的切线方向就是$R_0$和$R_1$，因此物体的​​位置和方向在起点和终点都是完全连续的​​，移动和转向看起来更加自然。</p><h4 id="​​Hermite样条​​原理"><a href="#​​Hermite样条​​原理" class="headerlink" title="​​Hermite样条​​原理"></a>​​Hermite样条​​原理</h4><p>三维空间中的自由曲线用三次参数方程表示可以用以下的形式：</p><script type="math/tex; mode=display">\begin{cases}x(t) = a_x t^3 + b_x t^2 + c_x t + d_x \\\\y(t) = a_y t^3 + b_y t^2 + c_y t + d_y \\\\z(t) = a_z t^3 + b_z t^2 + c_z t + d_z\end{cases}</script><p>即</p><script type="math/tex; mode=display">Q(t) = at^3+bt^2+ct+d</script><p>其中，$t \in [0,1]$ 表示从端点1到端点2的的相对距离。<br>将以上参数方程改写为矩阵形式为：</p><script type="math/tex; mode=display">Q(t) = [t^3,t^2,t,1][a,b,c,d]^T</script><p>令</p><script type="math/tex; mode=display">T=[t^3,t^2,t,1]</script><script type="math/tex; mode=display">C=[a,b,c,d]^T</script><p>则</p><script type="math/tex; mode=display">Q(t) = TC</script><p>求一阶导数，则有：</p><script type="math/tex; mode=display">Q'(t)=[3t^2,2t,1,0]C</script><p>对于已知的已知曲线的两个端点的位置矢量$P_{0}$、$P_{1}$以及两个端点处的切线矢量$R_{0}$、$R_{1}$，这四个量实际上对应于将$t=0$和$t=1$代入$Q(t)$、$Q^{‘}(t)$得到的结果:</p><script type="math/tex; mode=display">\begin{cases}P_0 = Q(0) = [0,0,0,0]C \\\\P_1 = Q(1) = [1,1,1,1]C \\\\R_0 = Q'(0) = [0,0,1,0]C \\\\R_1 = Q'(1) = [3,2,1,0]C\end{cases}</script><p>用矩阵方程表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}P_0 \\\\P_1 \\\\R_0 \\\\R_1\end{bmatrix} = \begin{bmatrix}0&0&0&1\\\\1&1&1&1\\\\0&0&1&0\\\\3&2&1&0\end{bmatrix}C</script><p>即</p><script type="math/tex; mode=display">C = \begin{bmatrix}0&0&0&1\\\\1&1&1&1\\\\0&0&1&0\\\\3&2&1&0\end{bmatrix}^{-1}\begin{bmatrix}P_0 \\\\P_1 \\\\R_0 \\\\R_1\end{bmatrix}</script><p>计算可得</p><script type="math/tex; mode=display">C=\begin{bmatrix}2&-2&1&1\\\\-3&3&-2&-1\\\\0&0&1&0\\\\1&0&0&0\end{bmatrix} \begin{bmatrix}P_0 \\\\P_1 \\\\R_0 \\\\R_1 \end{bmatrix}=M_hG_h</script><p>其中$M_{h}$即为Hermite矩阵，是一个常数，$G_{h}$为Hermite几何矢量。<br>所以曲线又可以表示为：</p><script type="math/tex; mode=display">Q=TM_hG_h</script><p>可以发现，只要给定$G_h$，就可以在$0\le t\le1$的范围内求出$Q(t)$，形成曲线上店的轨迹。$TM_h$称之为Hermite基函数记作$F(t)$，对基函数进一步展开，可得：</p><script type="math/tex; mode=display">F_0(t)=2t^3-3t^2+1 \\\\F_1(t)=-2t^3+3t^2 \\\\F_2(t)=t^3-2t^2+t \\\\F_3(t)=t^3-t^2</script><p>于是曲线上轨迹点可以通过下面的公式表示：</p><script type="math/tex; mode=display">x(t)=P_{0x}F_0(t)+P_{1x}F_1(t)+R_{0x}F_2(t)+R_{1x}F_3(t) \\\\y(t)=P_{0y}F_0(t)+P_{1y}F_1(t)+R_{0y}F_2(t)+R_{1y}F_3(t) \\\\z(t)=P_{0z}F_0(t)+P_{1z}F_1(t)+R_{0z}F_2(t)+R_{1z}F_3(t)</script><h2 id="影子跟随"><a href="#影子跟随" class="headerlink" title="影子跟随"></a>影子跟随</h2><p>（一下转载韦易笑在知乎的回答，详情见参考文档的第5条）<br>影子跟随算法由普通导航预测算法发展而来，称为“影子跟随”意在表示算法同步策略的主要思想：</p><ol><li>屏幕上现实的实体（entity）只是不停的追逐它的“影子”（shadow）。</li><li>服务器向各客户端发送各个影子的状态改变（坐标，方向，速度，时间）。</li><li>各个客户端收到以后按照当前重新插值修正影子状态。</li><li>影子状态是跳变的，但实体追赶影子是连续的，故整个过程是平滑的。</li></ol><h3 id="影子跟随算法在CS中的应用"><a href="#影子跟随算法在CS中的应用" class="headerlink" title="影子跟随算法在CS中的应用"></a>影子跟随算法在CS中的应用</h3><img src="/posts/2434505821/CS%E4%B8%AD%E7%9A%84%E5%BD%B1%E5%AD%90%E8%B7%9F%E9%9A%8F.png" class="" title="CS中的影子跟随"><p>实现CS，首先需要给人物移动加上惯性，比如静止状态突然开始移动，那么需要0.5-1秒的加速过程，而移动中突然停止也需要0.5-1秒的减速过程，这样就实现了无差别同步，不需要相位滞后来避免拉扯影响用户感。</p><p>同时开枪射击采用客户端判断，也就是说如果我看见你在墙前面，开枪射中，那么我向服务器发送“我击中你了”，这时有可能真实的你在墙后，那么表现出来的就是我看见我打中你了（减不减血由服务段判断），而你没有看见我，觉得我穿墙打中你了。</p><p>关键状态进行缓存，不然如果别人向前连续跳五次，每次取得状态都取到最高点的话，别人客户端上的影子和跟随的实体会奇怪的持续的飞在天上，所以需要将起跳和落地这两个关键状态缓存，实体追赶时只有追上的第一个状态（一号影子）才能追逐第二个状态（二号影子）。</p><h2 id="延迟补偿"><a href="#延迟补偿" class="headerlink" title="延迟补偿"></a>延迟补偿</h2><p>（以下是V社发布的《半条命》游戏技术文章中关于延迟补偿的翻译）</p><p>理解插值法对设计延迟补偿至关重要，因为插值是影响用户体验的另一种延迟形式。当玩家瞄准其他经过插值处理的对象时，服务器在计算命中判定时必须将插值量纳入考量。<br><strong>延迟补偿是一种在服务器端对世界状态进行时间归一化的方法，确保每位玩家执行操作时都能获得公平判定。</strong>您可以将其理解为：服务器通过时间回溯，重现玩家执行操作瞬间的真实世界状态。该算法运行流程如下：</p><p>在执行玩家当前操作指令前，服务器将：</p><ol><li>计算该玩家的精确网络延迟</li><li>从服务器历史记录中检索该玩家发出移动指令前最新接收的世界状态更新</li><li>基于该更新数据（根据精确目标时间选取相应版本），将更新中所有其他玩家的状态回溯到当前玩家操作发出时的历史位置。此回溯过程需同时计算连接延迟和客户端该帧使用的插值量</li><li>执行用户指令（包括武器射击等操作，这些操作将对处于”历史”位置的其他玩家进行射线检测）</li><li>将所有经位移/时间扭曲的玩家恢复至其正确/当前位置</li></ol><p>需要注意的是，在玩家状态回溯步骤中，可能还需同步回退附加状态信息（如玩家生存状态、下蹲动作等）。延迟补偿的最终效果是让每位本地玩家能够直接瞄准目标进行射击，无需通过预判移动轨迹来命中目标。当然，这种机制本身是一种游戏设计上的权衡。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《腾讯游戏开发精粹Ⅲ》 适用于MOBA游戏的帧同步移动预表现方案</li><li>GDC-2017《Overwatch Gameplay Architecture and Netcode》</li><li><a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization">Server In-game Protocol Design and Optimization</a></li><li><a href="https://blog.csdn.net/qq_28249373/article/details/130185579">曲线平滑算法：三次Hermite曲线生成</a></li><li><a href="https://www.zhihu.com/question/29076648">韦易笑-关于影子跟随算法的知乎回答</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
          <category> 网络同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树算法</title>
      <link href="/posts/2274644961/"/>
      <url>/posts/2274644961/</url>
      
        <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>再讲解最小生成树算法之前，需要复健几个概念，了解的朋友可以跳过：</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><strong>图 (graph)</strong> 是一个二元组 $G=(V(G), E(G))$。其中 $V(G)$ 是非空集，称为<strong>点集 (vertex set)</strong>，对于 $V$ 中的每个元素，我们称其为<strong>顶点 (vertex)</strong> 或<strong>节点 (node)</strong>，简称 <strong>点</strong>；$E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 <strong>边集 (edge set)</strong>。<br>常用 $G=(V,E)$ 表示图。</p><p>图有多种，包括<strong>无向图 (undirected graph)</strong>，<strong>有向图 (directed graph)</strong>，<strong>混合图 (mixed graph)</strong> 等。<br>若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$，称作<strong>无向边 (undirected edge)</strong>，简称<strong>边 (edge)</strong>，其中 $u, v \in V$。设 $e = (u, v)$，则 $u$ 和 $v$ 称为 $e$ 的<strong>端点 (endpoint)</strong>。<br>若$G$ 为有向图，则 $E$ 中的每一个元素为一个有序二元组 $(u, v)$，有时也写作 $u \to v$，称作<strong>有向边 (directed edge)</strong> 或<strong>弧 (arc)</strong>，在不引起混淆的情况下也可以称作<strong>边 (edge)</strong>。设 $e = u \to v$，则此时 $u$ 称为 $e$ 的<strong>起点 (tail)</strong>，$v$ 称为 $e$ 的<strong>终点 (head)</strong>，起点和终点也称为 $e$ 的<strong>端点 (endpoint)</strong>。并称 $u$ 是 $v$ 的直接前驱，$v$ 是 $u$ 的直接后继。<br>若 $G$ 为混合图，则 $E$ 中既有<strong>有向边</strong>，又有<strong>无向边</strong>。<br>若 $G$ 的每条边 $e_k=(u_k,v_k)$ 都被赋予一个数作为该边的<strong>权</strong>，则称 $G$ 为<strong>带权图</strong>。如果这些权都是正实数，就称 $G$ 为<strong>正权图</strong>。</p><p>形象地说，图是由若干点以及连接点与点的边构成的。</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>对一张图 $G=(V,E)$，若存在另一张图 $H=(V’,E’)$ 满足 $V’\subseteq V$ 且 $E’\subseteq E$，则称 $H$ 是 $G$ 的<strong>子图（subgraph）</strong>，记作 $H\subseteq G$。</p><h3 id="连通"><a href="#连通" class="headerlink" title="连通"></a>连通</h3><p>对于一张无向图 $G = (V, E)$，对于 $u, v \in V$，若存在一条途径使得 $v_0 = u, v_k = v$，则称 $u$ 和 $v$ 是<strong>连通的 (connected)</strong>。由定义，任意一个顶点和自身连通，任意一条边的两个端点连通。<br>若无向图 $G = (V, E)$，满足其中任意两个顶点均连通，则称 $G$ 是<strong>连通图 (connected graph)</strong>，$G$ 的这一性质称作<strong>连通性 (connectivity)</strong>。<br>若 $H$ 是 $G$ 的一个连通子图，且不存在 $F$ 满足 $H\subsetneq F \subseteq G$ 且 $F$ 为连通图，则 $H$ 是 $G$ 的一个<strong>连通块/连通分量 (connected component)（极大连通子图）</strong>。<br>若 $H$ 是 $G$ 的一个连通子图，并且满足从 $H$ 中移除​​任意一条边​​都会导致其不再连通（即 $H$ 的边集是保持连通所需的最少边数，没有冗余边）,则 $H$ 是 $G$ 的一个<strong>极小连通子图 (Minimal Connected Subgraph)</strong>。</p><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>一个无向连通图的生成树是它的极小连通子图，若图中含有 $n$ 个定点，则其生成树由 $n-1$ 条边构成。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们定义无向连通图的<strong>最小生成树（Minimum Spanning Tree，MST）</strong>为边权和最小的生成树。<br>注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。同一带权图可能有多棵最小生成树。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>构造最小生成树的方法有很多种，典型的有两种：$Kruskal$算法和$Prim$算法。这两个算法都采用了逐步求解的策略（<strong>贪心策略</strong>）：给定带权图$G=(V, E)$，$V$中共有$n$个顶点。首先构造一个包括全部$n$个顶点和0条边的森林$F=\{T_0,T_1,…,T_{n-1}\}$，然后不断迭代。每经过一轮迭代，就会在$F$中引入一条边。经过$n-1$轮迭代，最终得到一棵包含$n-1$条边的最小生成树。<br>下面详细介绍一下这两个算法。</p><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>$Kruskal$算法核心要义是将所有的边按照从小到大排序，从最短边开始依次选择，将不连通的两个端点连接在一起，最后可以得到一个树结构，且其总边长度是所有可能生成树中最小的。该算法是基于并查集的，并查集相关理论可以查看文章<a href="/posts/3306641566/" title="并查集">并查集</a>。</p><p>其运行步骤如下：</p><ol><li>生成所有边的列表，为每一个节点建立一个集合，每个集合只包含该节点自己</li><li>对于边列表，只要列表中还有边，从中取出一个权值更低的：<ol><li>如果这条边的两个端点属于不同的集合：<ol><li>将两个节点连接</li><li>将两个节点各自的集合互相合并</li></ol></li><li>从列表中删掉这条边</li></ol></li></ol><p>其中，查询两点是否连通和连接两点可以使用并查集维护。</p><p>如果使用$O(m\log m)$的排序算法，并且使用$O(m\alpha(m,n))$或$O(m\log (n))$的并查集，就可以得到时间复杂度为$O(m\log m)$的$Kruskal$算法。</p><p>我们使用文章<a href="/posts/3306641566/" title="并查集">并查集</a>中写的并查集基础库来进行该算法的实现。我们设想下图所示的一个图：<br>它的边和权重在图中标注了出来。<br><img src="/posts/2274644961/Kruskal%E4%B8%BE%E4%BE%8B.drawio.svg" class=""></p><p>Kruskal的C#代码实现如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边的结构体，表示图中的一条边</span></span><br><span class="line"><span class="keyword">struct</span> Edge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> start;   <span class="comment">// 起始顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> end;     <span class="comment">// 结束顶点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> weight;  <span class="comment">// 边的权重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建包含5个顶点的并查集</span></span><br><span class="line">    UFSet ufSet = <span class="keyword">new</span> UFSet(<span class="number">5</span>);</span><br><span class="line">    ufSet.Print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义图的边集合（8条边）</span></span><br><span class="line">    Edge[] edges = <span class="keyword">new</span> Edge[<span class="number">8</span>];</span><br><span class="line">    edges[<span class="number">0</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">0</span>, end = <span class="number">1</span>, weight = <span class="number">1</span> &#125;;</span><br><span class="line">    edges[<span class="number">1</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">0</span>, end = <span class="number">2</span>, weight = <span class="number">2</span> &#125;;</span><br><span class="line">    edges[<span class="number">2</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">1</span>, end = <span class="number">2</span>, weight = <span class="number">3</span> &#125;;</span><br><span class="line">    edges[<span class="number">3</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">0</span>, end = <span class="number">3</span>, weight = <span class="number">3</span> &#125;;</span><br><span class="line">    edges[<span class="number">4</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">3</span>, end = <span class="number">2</span>, weight = <span class="number">5</span> &#125;;</span><br><span class="line">    edges[<span class="number">5</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">3</span>, end = <span class="number">4</span>, weight = <span class="number">7</span> &#125;;</span><br><span class="line">    edges[<span class="number">6</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">0</span>, end = <span class="number">4</span>, weight = <span class="number">4</span> &#125;;</span><br><span class="line">    edges[<span class="number">7</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">2</span>, end = <span class="number">4</span>, weight = <span class="number">6</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按权重从小到大排序边</span></span><br><span class="line">    Array.Sort(edges, (e1, e2) =&gt; e1.weight.CompareTo(e2.weight));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行Kruskal算法</span></span><br><span class="line">    Kruskal(ufSet, edges);</span><br><span class="line"></span><br><span class="line">    ufSet.Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Kruskal算法实现最小生成树</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ufSet&quot;&gt;</span>并查集，用于判断是否形成环<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;edges&quot;&gt;</span>已排序的边数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Kruskal</span>(<span class="params">UFSet ufSet, Edge[] edges</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> selectedEdges = <span class="number">0</span>;  <span class="comment">// 已选择的边数</span></span><br><span class="line">    <span class="built_in">int</span> totalVertices = <span class="number">5</span>;  <span class="comment">// 总顶点数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; edges.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果已经选择了足够的边（n-1条边），提前结束</span></span><br><span class="line">        <span class="keyword">if</span> (selectedEdges &gt;= totalVertices - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 找到两个顶点的根节点</span></span><br><span class="line">        <span class="built_in">int</span> root1 = ufSet.Find(edges[i].start);</span><br><span class="line">        <span class="built_in">int</span> root2 = ufSet.Find(edges[i].end);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果两个顶点不在同一个连通分量中，则不会形成环</span></span><br><span class="line">        <span class="keyword">if</span> (root1 != root2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 合并两个连通分量</span></span><br><span class="line">            ufSet.Union(root1, root2);</span><br><span class="line">            selectedEdges++;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;选择边 (<span class="subst">&#123;edges[i].start&#125;</span>, <span class="subst">&#123;edges[i].end&#125;</span>): 权重 <span class="subst">&#123;edges[i].weight&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">选择边 (3, 4): 权重 1</span><br><span class="line">选择边 (2, 4): 权重 2</span><br><span class="line">选择边 (0, 4): 权重 3</span><br><span class="line">选择边 (1, 2): 权重 5</span><br><span class="line"></span><br><span class="line">1 -5 0 2 3 （经过Kruskal算法后的最小生成树并查集）</span><br></pre></td></tr></table></figure></p><p>可以看出来，最后形成了如下这样的最小生成树：<br><img src="/posts/2274644961/Kruskal%E4%B8%BE%E4%BE%8B%E8%BF%87%E7%A8%8B.drawio.svg" class=""></p><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。$Prim$算法的实现思路是：</p><ol><li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。初始状态下，所有顶点位于 B 类</li><li>选择任意一个顶点，将其从 B 类移动到 A 类</li><li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最优的边，将此边连接着的 A 类中的顶点移动到 B 类</li><li>重复执行第 3  步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边</li></ol><p>具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。这里每次找到距离最小的一个点，可以暴力找也可以用堆维护。<br>堆优化的方式类似 Dijkstra 的堆优化，但如果使用二叉堆等不支持 $O(1)$ decrease-key 的堆，复杂度就不优于 Kruskal，常数也比 Kruskal 大。所以，一般情况下都使用 Kruskal 算法，在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但不一定实际跑得更快。</p><p>我们继续使用Kruskal举例的图：<br><img src="/posts/2274644961/Kruskal%E4%B8%BE%E4%BE%8B.drawio.svg" class=""></p><p>Prim的C#代码实现如下（使用暴力查询下一个最优点）：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Edge[] edges = <span class="keyword">new</span> Edge[<span class="number">8</span>]; <span class="comment">// 边</span></span><br><span class="line">    edges[<span class="number">0</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">0</span>, end = <span class="number">1</span>, weight = <span class="number">7</span> &#125;;</span><br><span class="line">    edges[<span class="number">1</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">0</span>, end = <span class="number">2</span>, weight = <span class="number">6</span> &#125;;</span><br><span class="line">    edges[<span class="number">2</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">1</span>, end = <span class="number">2</span>, weight = <span class="number">5</span> &#125;;</span><br><span class="line">    edges[<span class="number">3</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">0</span>, end = <span class="number">3</span>, weight = <span class="number">5</span> &#125;;</span><br><span class="line">    edges[<span class="number">4</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">2</span>, end = <span class="number">3</span>, weight = <span class="number">3</span> &#125;;</span><br><span class="line">    edges[<span class="number">5</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">3</span>, end = <span class="number">4</span>, weight = <span class="number">1</span> &#125;;</span><br><span class="line">    edges[<span class="number">6</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">0</span>, end = <span class="number">4</span>, weight = <span class="number">3</span> &#125;;</span><br><span class="line">    edges[<span class="number">7</span>] = <span class="keyword">new</span> Edge() &#123; start = <span class="number">2</span>, end = <span class="number">4</span>, weight = <span class="number">2</span> &#125;;</span><br><span class="line">    Array.Sort(edges, (e1, e2) =&gt; e1.weight.CompareTo(e2.weight));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方便后续计算，这里构建邻接表</span></span><br><span class="line">    List&lt;Edge&gt;[] graph = <span class="keyword">new</span> List&lt;Edge&gt;[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> List&lt;Edge&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边到邻接表（无向图，双向添加）</span></span><br><span class="line">    <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edges)</span><br><span class="line">    &#123;</span><br><span class="line">        graph[edge.start].Add(<span class="keyword">new</span> Edge &#123; start = edge.start, end = edge.end, weight = edge.weight &#125;);</span><br><span class="line">        graph[edge.end].Add(<span class="keyword">new</span> Edge &#123; start = edge.end, end = edge.start, weight = edge.weight &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prim算法生成最小生成树</span></span><br><span class="line">    List&lt;Edge&gt; mst = Prim(graph, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小生成树的边</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;最小生成树的边：&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> mst)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;edge.start&#125;</span> - <span class="subst">&#123;edge.end&#125;</span> : <span class="subst">&#123;edge.weight&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Edge&gt; <span class="title">Prim</span>(<span class="params">List&lt;Edge&gt;[] graph, <span class="built_in">int</span> vertexCount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Edge&gt; mst = <span class="keyword">new</span> List&lt;Edge&gt;(); <span class="comment">// 存储最小生成树的边</span></span><br><span class="line">    <span class="built_in">bool</span>[] visited = <span class="keyword">new</span> <span class="built_in">bool</span>[vertexCount]; <span class="comment">// 标记顶点是否已访问</span></span><br><span class="line">    <span class="built_in">int</span>[] minWeight = <span class="keyword">new</span> <span class="built_in">int</span>[vertexCount]; <span class="comment">// 存储到各顶点的最小权重</span></span><br><span class="line">    <span class="built_in">int</span>[] parent = <span class="keyword">new</span> <span class="built_in">int</span>[vertexCount]; <span class="comment">// 存储最小生成树中的父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertexCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minWeight[i] = <span class="built_in">int</span>.MaxValue; <span class="comment">// 初始化为最大值</span></span><br><span class="line">        parent[i] = <span class="number">-1</span>; <span class="comment">// 无父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶点0开始</span></span><br><span class="line">    minWeight[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertexCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 找到未访问的最小权重顶点</span></span><br><span class="line">        <span class="built_in">int</span> minVertex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; vertexCount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; (minVertex == <span class="number">-1</span> || minWeight[j] &lt; minWeight[minVertex]))</span><br><span class="line">            &#123;</span><br><span class="line">                minVertex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记为已访问</span></span><br><span class="line">        visited[minVertex] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将边加入最小生成树（起始顶点除外）</span></span><br><span class="line">        <span class="keyword">if</span> (parent[minVertex] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mst.Add(<span class="keyword">new</span> Edge</span><br><span class="line">            &#123;</span><br><span class="line">                start = parent[minVertex],</span><br><span class="line">                end = minVertex,</span><br><span class="line">                weight = minWeight[minVertex]</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 更新邻接顶点的最小权重</span></span><br><span class="line">        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> graph[minVertex])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[edge.end] &amp;&amp; edge.weight &lt; minWeight[edge.end])</span><br><span class="line">            &#123;</span><br><span class="line">                minWeight[edge.end] = edge.weight;</span><br><span class="line">                parent[edge.end] = minVertex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最小生成树的边：</span><br><span class="line">0 - 4 : 3</span><br><span class="line">4 - 3 : 1</span><br><span class="line">4 - 2 : 2</span><br><span class="line">2 - 1 : 5</span><br></pre></td></tr></table></figure><p>和Kruskal算法的运行结果一致。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/posts/3306641566/"/>
      <url>/posts/3306641566/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>并查集主要针对一些需要将元素按某一规律进行分类，反复查询某个元素归属于哪个集合的应用场景。<br>如其名字一样，并查集（union-find set）的主要操作为对元素的合并（union）和查找（find），如下：</p><ol><li>Union(element1, element2)：把元素element2所在集合并入元素element1所在集合。要求两个集合不相交。</li><li>Find(x)：搜索单元素x所在的集合，并返回该集合的名字。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>并查集中需要两种数据类型的参数：集合名类型和集合元素类型。许多情况下，可以用整数作为集合名。实现并查集的一个典型方法是采用树形结构来表示元素及其所属子集的关系。<br>用这种实现方式，每个集合以一棵树表示，树的每一个结点代表集合的一个单元素。所有各个集合的全集合构成一个森林，并用树与森林的父指针表示来实现。其下标代表元素名。第$i$个数组元素代表包含元素$i$的树结点。树的根结点的下标代表集合名，根结点的父为集合中的元素个数的相反数，是负数。</p><p>我们设有一个全集合为$S=\{0,1,2,3,4,5,6,7,10\}$ ，初始化时每个元素自成一个单元素集合。此时的森林形态和并查集数组表示如下：</p><img src="/posts/3306641566/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96.drawio.svg" class=""><p>我们将该元素合集按$f(x)=x mod(3)$的结果来进行分类，经过计算后，可以得到3个集合，分别为$S_1=\{0,3,6\}$，$S_2=\{1,4,7,10\}$，$S_3=\{2,5\}$，此时的森林形态和并查集数组表示如下：</p><img src="/posts/3306641566/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9B%B4%E6%96%B01.drawio.svg" class=""><p>在父指针数组表示中，在同一棵树上所有结点的代表的集合元素在同一个子集合中。对于任意给定的集合元素x，只要借助这个映射，就能找到存放x的树结点。由于我们已经将树结点从子女到父结点通过父指针链接起来了，因此沿此存放x的结点的父指针向上一路寻找直到树的根结点，就可以得到x所在的集合的名字。</p><p>这里我们再考虑两个集合的并的情况，假设我们现在需要得到模3为0和模3为2的集合的并，即$S_{13} = S_1 \cup S_3$，只要将表示其中一个集合的树的根结点设置为另一个集合的树的根结点的子女即可。如下所示：</p><img src="/posts/3306641566/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%90%88%E5%B9%B6.drawio.svg" class=""><p>下面给出并查集的C#基础实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UFSet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] elementSets;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UFSet</span>(<span class="params"><span class="built_in">int</span> size = <span class="number">10</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        elementSets = <span class="keyword">new</span> <span class="built_in">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            elementSets[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Find</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (elementSets[x] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = elementSets[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span>(<span class="params"><span class="built_in">int</span> element1, <span class="built_in">int</span> element2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> root1 = Find(element1);</span><br><span class="line">        <span class="built_in">int</span> root2 = Find(element2);</span><br><span class="line">        elementSets[root1] += elementSets[root2];</span><br><span class="line">        elementSets[root2] = root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>为避免并查集退化成类似链表的数据结构。有以下几种优化方式：</p><h3 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h3><p>合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。<br>按节点数合并的参考实现：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WeightedUnion</span>(<span class="params"><span class="built_in">int</span> element1, <span class="built_in">int</span> element2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> root1 = Find(element1);</span><br><span class="line">    <span class="built_in">int</span> root2 = Find(element2);</span><br><span class="line">    <span class="built_in">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 != root2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = elementSets[root1]+elementSets[root2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (elementSets[root2] &lt; elementSets[root1])</span><br><span class="line">    &#123;</span><br><span class="line">        elementSets[root1] = root2;</span><br><span class="line">        elementSets[root2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        elementSets[root2] = root1;</span><br><span class="line">        elementSets[root1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ZipFind</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = x;elementSets[i] &gt;= <span class="number">0</span>;i = elementSets[i]);</span><br><span class="line">    <span class="keyword">while</span>(i != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = elementSets[x];</span><br><span class="line">        elementSets[x] = i;</span><br><span class="line">        i = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $O(\alpha(n))$。其中，$\alpha$ 为阿克曼函数的反函数，增长极其缓慢。也就是说，并查集单次操作的平均运行时间可以认为是一个很小的常数。空间复杂度显然为<br>$O(n)$。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://oi-wiki.org/ds/dsu/">oi-wiki/并查集</a></li><li>《数据结构（用面向对象方法与C++语言描述）》 殷人昆主编</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通信（七）高性能定点数实现</title>
      <link href="/posts/1154970394/"/>
      <url>/posts/1154970394/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本文参考《腾讯游戏开发精粹》高性能的定点数实现方案，是该文的读书笔记和实践记录。<br><span id="more"></span></p><h2 id="定点数结构"><a href="#定点数结构" class="headerlink" title="定点数结构"></a>定点数结构</h2><p>文章基于64位整型数实现定点数方案，约定第0-31位为小数部分，32-62位为整数部分，第63位为符号位，即32位有符号整数，32位小数。<br><img src="/posts/1154970394/64%E4%BD%8D%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%BB%93%E6%9E%84.png" class="" title="64位定点数的结构"><br>该方案能表示的范围为：</p><script type="math/tex; mode=display">[-2^{32},2^{31}-2^{-32}]</script><p>精度为：</p><script type="math/tex; mode=display">\frac{1}{2^{32}} = 2.3283064365386963\times10^{-10}</script><p>在数学上，把整数的二进制表示中较低的$n$位视为小数部分，那么一个整数的二进制形式表示的定点数值其实就是这个整数值除以$2^n$。设$a$为定点数，$f(a)$为这个定点数对应的整数值，即$f(a)$是一个整数，$a$是它所表示的定点数，那么有</p><script type="math/tex; mode=display">a=2^{-n}f(a)</script><p>不同项目可以根据自己实际情况，按所需精度来确定小数位数。</p><h2 id="定点数四则运算"><a href="#定点数四则运算" class="headerlink" title="定点数四则运算"></a>定点数四则运算</h2><h3 id="定点数加减法"><a href="#定点数加减法" class="headerlink" title="定点数加减法"></a>定点数加减法</h3><p>浮点数的加减需要先对齐阶码（相当对齐小数点）​，然后再相加减。而定点数的小数点是对齐的，可以直接使用对应的整数的加减法。</p><h3 id="定点数乘法"><a href="#定点数乘法" class="headerlink" title="定点数乘法"></a>定点数乘法</h3><p>浮点数的乘法是通过整数部分相乘、阶码相加实现的。<br>对于64位定点数，需要实现了一个双倍宽度（128位）的有符号整数的乘法运算。<br>对于64位<code>GCC</code>编译器，可以直接使用<code>_int128_t</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_int64_t</span> value = (<span class="type">_int128_t</span>(a) ＊ b) ＞＞ <span class="number">32</span>;</span><br></pre></td></tr></table></figure><br>如果没有原生支持的接口，则需要自己实现将倍精度运算分解为一系列单精度运算。即用 64 位整型去实现 128 位整型，如下GCC实现函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入​​：两个双字整数（各由 (l1, h1) 和 (l2, h2) 表示，其中 l 是低有效位，h 是高有效位）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ​​输出​​：</span></span><br><span class="line"><span class="comment">// (lv, hv)：乘积的低位双字（64位）。</span></span><br><span class="line"><span class="comment">// (lw, hw)：乘积的高位双字（64位），若 lw == NULL 则忽略。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ​​返回值​​：1 表示溢出，0 表示未溢出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ​​参数 unsigned_p​​：true 表示无符号乘法，false 表示有符号乘法。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mul_double_wide_with_sign</span> <span class="params">(<span class="type">unsigned</span> HOST_WIDE_INT l1, HOST_WIDE_INT h1,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">unsigned</span> HOST_WIDE_INT l2, HOST_WIDE_INT h2,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">unsigned</span> HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">unsigned</span> HOST_WIDE_INT *lw, HOST_WIDE_INT *hw,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">bool</span> unsigned_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HOST_WIDE_INT arg1[<span class="number">4</span>];</span><br><span class="line">  HOST_WIDE_INT arg2[<span class="number">4</span>];</span><br><span class="line">  HOST_WIDE_INT prod[<span class="number">4</span> * <span class="number">2</span>];</span><br><span class="line">  <span class="type">unsigned</span> HOST_WIDE_INT carry;</span><br><span class="line">  <span class="type">int</span> i, j, k;</span><br><span class="line">  <span class="type">unsigned</span> HOST_WIDE_INT neglow;</span><br><span class="line">  HOST_WIDE_INT neghigh;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">encode</span> (arg1, l1, h1);</span><br><span class="line">  <span class="built_in">encode</span> (arg2, l2, h2);</span><br><span class="line">  <span class="comment">// 将输入的64位整数拆分为4个16位块（假设 HOST_WIDE_INT 为16位），存储到数组 arg1[4] 和 arg2[4] 中。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span> (prod, <span class="number">0</span>, <span class="keyword">sizeof</span> prod);</span><br><span class="line"> <span class="comment">// 模拟小学乘法（竖式计算），逐位相乘并累加进位。</span></span><br><span class="line"> <span class="comment">// LOWPART(x)：取 x 的低16位（如 x &amp; 0xFFFF）。</span></span><br><span class="line"> <span class="comment">// HIGHPART(x)：取 x 的高16位（如 x &gt;&gt; 16）。</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      carry = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">  k = i + j;</span><br><span class="line">  <span class="comment">/* This product is &lt;= 0xFFFE0001, the sum &lt;= 0xFFFF0000.  */</span></span><br><span class="line">  carry += (<span class="type">unsigned</span> HOST_WIDE_INT) arg1[i] * arg2[j]; <span class="comment">// // 计算乘积</span></span><br><span class="line">  <span class="comment">/* Since prod[p] &lt; 0xFFFF, this sum &lt;= 0xFFFFFFFF.  */</span></span><br><span class="line">  carry += prod[k]; <span class="comment">// 累加之前的进位</span></span><br><span class="line">  prod[k] = <span class="built_in">LOWPART</span> (carry); <span class="comment">// 存储低16位</span></span><br><span class="line">  carry = <span class="built_in">HIGHPART</span> (carry);  <span class="comment">// 进位到高16位</span></span><br><span class="line">&#125;</span><br><span class="line">      prod[i + <span class="number">4</span>] = carry; <span class="comment">// 存储剩余进位</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// decode 将4个16位块组合回64位整数（(lv, hv) 和 (lw, hw)）。</span></span><br><span class="line">  <span class="built_in">decode</span> (prod, lv, hv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are not interested in the wide part nor in overflow.  */</span></span><br><span class="line">  <span class="keyword">if</span> (lw == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">decode</span> (prod + <span class="number">4</span>, lw, hw);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unsigned overflow is immediate.  */</span></span><br><span class="line">  <span class="comment">// 无符号乘法溢出检测</span></span><br><span class="line">  <span class="keyword">if</span> (unsigned_p)</span><br><span class="line">    <span class="keyword">return</span> (*lw | *hw) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for signed overflow by calculating the signed representation of the</span></span><br><span class="line"><span class="comment">     top half of the result; it should agree with the low half&#x27;s sign bit.  */</span></span><br><span class="line">    <span class="comment">// 符号修正​​：</span></span><br><span class="line">    <span class="comment">// 若输入为负数（h1 &lt; 0 或 h2 &lt; 0），需将高位部分加上另一个操作数的补码修正（模拟有符号乘法规则）。</span></span><br><span class="line">​    <span class="comment">// ​溢出判断​​：</span></span><br><span class="line">    <span class="comment">// 若结果低位为负（*hv &lt; 0），则高位应为全1（补码符号扩展），即检查 ~(*lw &amp; *hw) != 0。</span></span><br><span class="line">    <span class="comment">// 若结果低位非负（*hv &gt;= 0），则高位应为全0，即检查 *lw | *hw != 0。</span></span><br><span class="line">  <span class="keyword">if</span> (h1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">neg_double</span> (l2, h2, &amp;neglow, &amp;neghigh);</span><br><span class="line">      <span class="built_in">add_double</span> (neglow, neghigh, *lw, *hw, lw, hw);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (h2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">neg_double</span> (l1, h1, &amp;neglow, &amp;neghigh);</span><br><span class="line">      <span class="built_in">add_double</span> (neglow, neghigh, *lw, *hw, lw, hw);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> (*hv &lt; <span class="number">0</span> ? ~(*lw &amp; *hw) : *lw | *hw) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>两个定点数$a$和$b$的商可以表示为：</p><script type="math/tex; mode=display">\frac{a}{b} = \frac{2^{-n}f(a)}{2^{-n}f(b)} = 2^{-n}(2^{n}\frac{f(a)}{f(b)})</script><p>所以做除法运算需要乘以$2^{32}$，为避免溢出也需要引入128位的运算。除了类似乘法一样在C++层面实现128位除法外，书中还提供了一种汇编实现的128位除法。<br>在c++中声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> std::<span class="type">int64_t</span> _Div128_64(</span><br><span class="line">    std::<span class="type">int64_t</span>    a_low,</span><br><span class="line">    std::<span class="type">int64_t</span>    a_high,</span><br><span class="line">    std::<span class="type">int64_t</span>    b,</span><br><span class="line">    std::<span class="type">int64_t</span>＊   ret );</span><br></pre></td></tr></table></figure><br>把a_low的值传给寄存器rcx，把a_high的值传给rdx，把b的值传给r8，把ret的指针传给r9。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.code</span><br><span class="line">Div128_64 proc</span><br><span class="line">    mov rax, rcx     ; 将a_low的值由rcx传给rax</span><br><span class="line">    idiv r8          ; rdx - rax(128位被除数) / r8(除数) = rdx(余数), rax(商)</span><br><span class="line">    mov[r9], rdx     ; 通过指针传出余数</span><br><span class="line">    ret              ; 返回商</span><br><span class="line">ret;</span><br><span class="line">Div128_64 endp</span><br><span class="line">END</span><br></pre></td></tr></table></figure><br>但是因为不同CPU上的指令集是不同的，上述方法需要自己维护一套跨平台的算法库。</p><h2 id="定点数开方与超越函数"><a href="#定点数开方与超越函数" class="headerlink" title="定点数开方与超越函数"></a>定点数开方与超越函数</h2><h3 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h3><p>对于函数$f(x)$，在满足相关条件的情况下，可以使用泰勒展开式进行多项式拟合。<br>若函数$f(x)$在包含$x_0$的某个闭区间$[a,b]$上具有$n$阶导数，且在开区间$(a,b)$上具有$n+1$阶导数，则对闭区间$[a,b]$上任意一点x，成立下式：</p><script type="math/tex; mode=display">f(x)=\sum_{k=0}^{n} \frac{f^{(k)}(x_0)}{k!}\,(x-x_0)^k + R_{n}(x)</script><p>其中$f^{(n)}(x)$表示$f(x)$的$n$阶导数，剩余的$R_{n}(x)$是泰勒公式的余项，是$(x-x_0)^n$的高阶无穷小。它可以写成多种形式，比如拉格朗日余项公式：</p><script type="math/tex; mode=display">R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}, \xi \in [x,x_0] \space or \space \xi \in[x_0,x]</script><p>所以截取泰勒展开式前$n+1$项，与实际值的误差即是拉格朗日余项。</p><p>文章采用离线计算的方式，找出一个函数$P_n(x)$，使得在区间$[a,b]$上，最大误差的绝对值最小。简单的说，就是求这个多项式就是求原函数在指定区间上的最佳逼近。就是如果要求的点落在这个区间以外，那么就要利用函数的性质转换成这个区间内的点。<br>文章以对$e^x$函数在$[0,1]$区间上的拟合为例子。<br>通过数学软件Mathematica计算得到：</p><script type="math/tex; mode=display">e^x \approx 1.17974+0.380661x+1.32348x^2-0.350357x^3+0.184801x^4</script><h3 id="正弦余弦"><a href="#正弦余弦" class="headerlink" title="正弦余弦"></a>正弦余弦</h3><p>文章利用正弦余弦的周期性和对称性，把平面按$45\degree$为一块分成了8块。所以一般角度$x$的求解公式为：</p><script type="math/tex; mode=display">x=k\frac{\pi}{4}+x_1,k\in\mathbb{Z},k\in[0,7],x_1\in[0,\frac{\pi}{4})</script><p>因此，我们需要确认角度的终边落在哪一块。接下来就是求解终边和最近的坐标轴所在直线的夹角的正弦值和余弦值，再转换为我们要求解的角度的正弦值和余弦值。<br>这里记角的终边和最近的坐标轴所在直线的夹角为$\theta$。如果$k$是偶数，那么$\theta=x_1$；如果$k$是奇数，那么$\theta=\frac{\pi}{4}-x_1$。我们<strong>利用拟合多项式求出$\frac{\theta}{2}$的正弦值和余弦值</strong>，再利用二倍角公式得到$\sin\theta$, $\cos\theta$：</p><script type="math/tex; mode=display">\sin\theta = 2\sin\frac{\theta}{2}\cos\frac{\theta}{2} \\\cos\theta = 1 - 2\sin^2\frac{\theta}{2} = 2\cos^2\frac{\theta}{2}-1</script><p>然后根据角的终边所在的位置，我们就可以得到所要求的三角函数和$\sin\theta$, $\cos\theta$之间的关系。</p><h4 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h4><ol><li>角度归一化：将输入角度$x$归一到区间$[0,2\pi)$，记$\alpha=x\bmod 2\pi$。</li><li>扇区划分：令$k=\left\lfloor \alpha/(\pi/4) \right\rfloor\ (\bmod\ 8)$，并令$x_1=\alpha-k\cdot\frac{\pi}{4}$，其中$x_1\in[0,\frac{\pi}{4})$。</li><li>参考角选择：若$k$为偶数，$\theta=x_1$；若$k$为奇数，$\theta=\frac{\pi}{4}-x_1$。</li><li>半角近似：令$h=\theta/2$，使用离线拟合的多项式$P<em>{\sin}(h)$、$P</em>{\cos}(h)$近似$\sin h$、$\cos h$。</li><li>二倍角恢复：$\sin\theta=2\sin h\cos h$，$\cos\theta=1-2\sin^2 h$（或$2\cos^2 h-1$）。</li><li>扇区还原：按$k\in[0,7]$将$\sin\theta,\cos\theta$还原为$\sin x,\cos x$：<ul><li>$k=0$: $\sin x=+\sin\theta,\ \cos x=+\cos\theta$</li><li>$k=1$: $\sin x=\cos\theta,\ \cos x=\sin\theta$</li><li>$k=2$: $\sin x=\cos\theta,\ \cos x=-\sin\theta$</li><li>$k=3$: $\sin x=\sin\theta,\ \cos x=-\cos\theta$</li><li>$k=4$: $\sin x=-\sin\theta,\ \cos x=-\cos\theta$</li><li>$k=5$: $\sin x=-\cos\theta,\ \cos x=-\sin\theta$</li><li>$k=6$: $\sin x=-\cos\theta,\ \cos x=+\sin\theta$</li><li>$k=7$: $\sin x=-\sin\theta,\ \cos x=+\cos\theta$</li></ul></li></ol><p>以下是关键实现代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> fx;            <span class="comment">// Q32.32 定点数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> FRAC_BITS = <span class="number">32</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> fx FX_ONE = (fx)<span class="number">1</span> &lt;&lt; FRAC_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础运算</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fx <span class="title function_">fx_from_int</span><span class="params">(<span class="type">int32_t</span> i)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title function_">fx_to_int</span><span class="params">(fx a)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fx <span class="title function_">fx_mul</span><span class="params">(fx a, fx b)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fx <span class="title function_">fx_div</span><span class="params">(fx a, fx b)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fx <span class="title function_">fx_abs</span><span class="params">(fx a)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fx <span class="title function_">fx_mod</span><span class="params">(fx a, fx m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多项式拟合</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fx <span class="title function_">psin_half</span><span class="params">(fx h)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> fx <span class="title function_">pcos_half</span><span class="params">(fx h)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数：输入/输出均为 Q32.32（弧度）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fast_sin_cos_q32</span><span class="params">(fx x, fx* out_sin, fx* out_cos)</span> &#123;</span><br><span class="line">  <span class="comment">// 1) 归一化到 [0, 2π)</span></span><br><span class="line">  fx a = fx_mod(x, TWO_PI);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2) 扇区划分与 x1</span></span><br><span class="line">  <span class="type">int</span> k = (<span class="type">int</span>)(a / QUARTER_PI) &amp; <span class="number">7</span>;           <span class="comment">// 0..7</span></span><br><span class="line">  fx x1 = a - (fx)k * QUARTER_PI;              <span class="comment">// x1 ∈ [0, π/4)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3) 参考角 θ 以及半角 h</span></span><br><span class="line">  fx theta = (k % <span class="number">2</span> == <span class="number">0</span>) ? x1 : (QUARTER_PI - x1);</span><br><span class="line">  fx h = theta &gt;&gt; <span class="number">1</span>;                           <span class="comment">// θ/2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4) 近似 sin(h), cos(h)</span></span><br><span class="line">  fx s_h = psin_half(h);</span><br><span class="line">  fx c_h = pcos_half(h);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5) 二倍角：sinθ = 2*s_h*c_h，cosθ = 1 - 2*s_h^2</span></span><br><span class="line">  fx <span class="type">s_t</span> = (fx)( ( (__int128)<span class="number">2</span> * s_h * c_h ) &gt;&gt; FRAC_BITS );</span><br><span class="line">  fx s_h_sq = fx_mul(s_h, s_h);</span><br><span class="line">  fx <span class="type">c_t</span> = FX_ONE - (fx)( ( (__int128)<span class="number">2</span> * s_h_sq ) &gt;&gt; FRAC_BITS );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6) 扇区还原到 sin(x), cos(x)</span></span><br><span class="line">  <span class="keyword">switch</span> (k) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: *out_sin = +<span class="type">s_t</span>; *out_cos = +<span class="type">c_t</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: *out_sin = +<span class="type">c_t</span>; *out_cos = +<span class="type">s_t</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: *out_sin = +<span class="type">c_t</span>; *out_cos = -<span class="type">s_t</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: *out_sin = +<span class="type">s_t</span>; *out_cos = -<span class="type">c_t</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: *out_sin = -<span class="type">s_t</span>; *out_cos = -<span class="type">c_t</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: *out_sin = -<span class="type">c_t</span>; *out_cos = -<span class="type">s_t</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: *out_sin = -<span class="type">c_t</span>; *out_cos = +<span class="type">s_t</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: *out_sin = -<span class="type">s_t</span>; *out_cos = +<span class="type">c_t</span>; <span class="keyword">break</span>; <span class="comment">// k == 7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h3><p>文章将指数函数的输入$x$值拆分成整数部分和小数部分。</p><script type="math/tex; mode=display">x=[x]+\{x\}</script><p>以$e^x$函数为例，有：</p><script type="math/tex; mode=display">e^x=e^{[x]}e^{\{x\}}</script><p>其中，$e$是e的整数次方，很容易求解。而{x}属于[0,1]区间，在这个区间范围内指数函数可以方便地用多项式拟合。</p><h3 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h3><p>文章使用换底公式将一般对数转换为以2为底的对数形式：</p><script type="math/tex; mode=display">\log_mx=\frac{\log_2{x}}{\log_2m}</script><p>其中x可约化为</p><script type="math/tex; mode=display">x=2^ny,n\in\mathbb{Z},y\in[0,1)</script><p>则</p><script type="math/tex; mode=display">\log_2x=n+\log_2y</script><p>因为这里的定点数是基于整数的二进制实现的，所以知道最高位的1的位置就可以求出n。余下的部分可以用拟合多项式求解。</p><h3 id="开方运算"><a href="#开方运算" class="headerlink" title="开方运算"></a>开方运算</h3><p>文章介绍了四种开方运算方式，分别是：</p><h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>经典的迭代开方运算法，具体可看下面文章中对牛顿迭代法的介绍。<br><a href="/posts/850070085/" title="快速平方根倒数算法">牛顿迭代法</a><br>其定点数代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fx <span class="title">sqrt_newton</span><span class="params">(fx n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  fx x = (n &gt; FX_ONE) ? n : FX_ONE; <span class="comment">// 初始值：&gt;=1 用 n，否则用 1.0</span></span><br><span class="line">  <span class="comment">// 24 次迭代足够 Q32.32 达到 1 LSB 精度，且设有早停条件。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i) &#123;</span><br><span class="line">    fx prev = x;</span><br><span class="line">    x = (x + <span class="built_in">fx_div</span>(n, x)) &gt;&gt; <span class="number">1</span>; <span class="comment">// (x + n/x) / 2</span></span><br><span class="line">    fx delta = (x &gt; prev) ? (x - prev) : (prev - x);</span><br><span class="line">    <span class="keyword">if</span> (delta &lt;= <span class="number">1</span>) <span class="keyword">break</span>;       <span class="comment">// 收敛到 1 LSB 以内</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>进一步，可以参考快速平方根导数的做法，让近似值选择更加精确。</p><h4 id="借用浮点数开方"><a href="#借用浮点数开方" class="headerlink" title="借用浮点数开方"></a>借用浮点数开方</h4><p>已知定点数$y$，我们要求定点数$x$使得$x^2=y$。根据之前对定点数的运算和它对应的整数运算的关系，有：</p><script type="math/tex; mode=display">(f(x))^2=2^nf(y)</script><p>   其中，$f(x)$，$f(y)$分别是定点数$x$，$y$对应的整数，可以先把整数$2^nf(y)$转换为浮点数进行开根号，再取整。那么$f(x)$只能取$[\sqrt{2^nf(y)}]$附近一定范围内的整数。我们选择平方后和$2^nf(y)$最接近的一项，在大部分情况下比较$[\sqrt{2^nf(y)}]$，$[\sqrt{2^nf(y)}]+1$两项即可。</p><h4 id="整数开方法"><a href="#整数开方法" class="headerlink" title="整数开方法"></a>整数开方法</h4><p>可以根据之前论述的定点数的值和它对应的整数值之间的关系，对其对应的整数开方。常见的有逐二进制<br>位开方法。这种算法对每个二进制位进行位运算和加减法，通过一个bit一个bit去试验，来测出平方根<br>的每个bit的值。<br>逐二进制开方算法假定对数值x求出的平方根结果的位数肯定小于x的位数的一半。因此对于64位整数求平方根，可以只测试其中的32个bit。<br>设定点数 $y$ 的底层整数为 $R_y$，定点数$x$的底层整数为$R_x$，$y$和$x$满足$y=\sqrt{x}$，现知道$x$需要求解其开方后的值$y$，可得：</p><script type="math/tex; mode=display">y=\sqrt{x} \Rightarrow R_y2^{-32} = \sqrt{R_x2^{-32}}</script><p>有：</p><script type="math/tex; mode=display">R_y=2^{16}\sqrt{R_x}=\sqrt{R_x}<<16</script><p>因此可对 $\sqrt{R_x}$ 执行纯整数平方根。下面给出逐二进制位开方的简单实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fx <span class="title">int_sqrt_q32</span><span class="params">(fx x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> Rx = (<span class="type">uint64_t</span>)x;        <span class="comment">// 底层非负整数 R_x</span></span><br><span class="line">    <span class="type">uint64_t</span> n  = <span class="number">0</span>;                  <span class="comment">// floor(sqrt(Rx))，最多 32 位</span></span><br><span class="line">    <span class="type">uint64_t</span> b  = <span class="number">1ull</span> &lt;&lt; <span class="number">31</span>;         <span class="comment">// 从最高位开始试探</span></span><br><span class="line">    <span class="type">int</span> v_bit   = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="type">__uint128_t</span> trial = ((<span class="type">__uint128_t</span>)((n &lt;&lt; <span class="number">1</span>) + b)) &lt;&lt; v_bit; <span class="comment">// ((n&lt;&lt;1)+b) &lt;&lt; v_bit</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">__uint128_t</span>)Rx &gt;= trial) &#123;</span><br><span class="line">            n  += b;</span><br><span class="line">            Rx -= (<span class="type">uint64_t</span>)trial;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        --v_bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (fx)(n &lt;&lt; <span class="number">16</span>); <span class="comment">// R_y = (sqrt(R_x)) &lt;&lt; 16  → Q32.32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="多项式拟合-1"><a href="#多项式拟合-1" class="headerlink" title="多项式拟合"></a>多项式拟合</h4><p>我们可以对定点数的小数点位置进行调整，如：$\sqrt{x}=2^{n}\sqrt{x_n}$使得$\sqrt{x_n}$满足在$[0,1]$区间上，以便更好的进行多项式拟合。</p><h3 id="开方倒数"><a href="#开方倒数" class="headerlink" title="开方倒数"></a>开方倒数</h3><p>浮点数的快速开平方倒数算法详情见下面的文章。<br><a href="/posts/850070085/" title="快速平方根倒数算法">快速平方根倒数算法</a><br>和该方法类似，文章里使用四次多项式拟合公式先找到了一个比较精确的近似值，然后再通过牛顿迭代法计算一次，缩小误差。</p>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
          <category> 网络同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 帧同步 </tag>
            
            <tag> 定点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速平方根倒数算法</title>
      <link href="/posts/850070085/"/>
      <url>/posts/850070085/</url>
      
        <content type="html"><![CDATA[<p>先直接给出著名的快速平方根导数算法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** float q_rsqrt( float number )</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="type">float</span> number )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="type">long</span> i;  </span><br><span class="line">   <span class="type">float</span> x2, y;  </span><br><span class="line">   <span class="type">const</span> <span class="type">float</span> threehalfs = <span class="number">1.5F</span>;  </span><br><span class="line"> </span><br><span class="line">   x2 = number * <span class="number">0.5F</span>;  </span><br><span class="line">   y  = number;  </span><br><span class="line">   i  = * ( <span class="type">long</span> * ) &amp;y;                       <span class="comment">// evil floating point bit level hacking  </span></span><br><span class="line">   i  = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );               <span class="comment">// what the fuck?  </span></span><br><span class="line">   y  = * ( <span class="type">float</span> * ) &amp;i;  </span><br><span class="line">   y  = y * ( threehalfs - ( x2 * y * y ) );   <span class="comment">// 1st iteration  </span></span><br><span class="line"><span class="comment">// y = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed  </span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> y;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>函数中最核心的代码就四行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i  = * ( <span class="type">long</span> * ) &amp;y;                       <span class="comment">// evil floating point bit level hacking  </span></span><br><span class="line">i  = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );               <span class="comment">// what the fuck?  </span></span><br><span class="line">y  = * ( <span class="type">float</span> * ) &amp;i;  </span><br><span class="line">y  = y * ( threehalfs - ( x2 * y * y ) );   <span class="comment">// 1st iteration  </span></span><br></pre></td></tr></table></figure><br>下面详细说明一下这四行。</p><h2 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = * ( <span class="type">long</span> * ) &amp;y;   <span class="comment">// evil floating point bit level hacking  </span></span><br></pre></td></tr></table></figure><p>将浮点数 y 的32位IEEE 754表示直接视为整数。对于规格化的正浮点数$x$有：</p><script type="math/tex; mode=display">x = (1+2^{-23}M)2^E</script><p>其中M为尾数，E为阶码，将其转化为的整数$I_x$的值为公式（1）：</p><script type="math/tex; mode=display">I_x=M+2^{23}(E+2^7-1)</script><p>这里因为阶码E是移码形式编码，且偏移值是$2^7-1$，所以后面需要加上这部分偏移值。<br>这行代码就是让$i=I_x$。</p><h2 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> );  <span class="comment">// what the fuck?  </span></span><br></pre></td></tr></table></figure><p>我们设需要求的平方根导数为$y$，则有$y=\frac{1}{\sqrt{x}}$。<br>两边取对数，得</p><script type="math/tex; mode=display">\log_2{y} = -\frac{1}{2}\log_2x</script><p>将浮点数格式代入，得</p><script type="math/tex; mode=display">\log_2{y} = -\frac{1}{2}\log_2{((1+2^{-23}M)2^E)}</script><p>整理得</p><script type="math/tex; mode=display">\log_2{y} = -\frac{1}{2}[\log_2{(1+2^{-23}M)}+E]</script><p>对于函数$f(x)=\log_2{(1+x)}$，根据在0点的泰勒展开式，有</p><script type="math/tex; mode=display">f(x) = \log_2{(1+x)}=0+f^{'}(0)+R_1(x) \approx x + \sigma</script><p>上式的意义是证明了函数$f(x)$大致和$x$相等，其中$\sigma$是一个可优化的偏移参数。<br>所以，原式可以转化为</p><script type="math/tex; mode=display">\log_2{y} \approx -\frac{1}{2}(2^{-23}M+\sigma+E)</script><p>根据(3)式可得</p><script type="math/tex; mode=display">\log_2y\approx-\frac{1}{2}(2^{-23}I_x-2^7+1+\sigma)</script><p>同理可得</p><script type="math/tex; mode=display">\log_2y\approx2^{-23}I_y-2^7+1+\sigma_y</script><p>代入得</p><script type="math/tex; mode=display">2^{-23}I_y-2^7+1+\sigma_y\approx-\frac{1}{2}(2^{-23}I_x-2^7+1+\sigma)</script><p>整理得</p><script type="math/tex; mode=display">I_y\approx\frac{3}{2}(2^7-1-\sigma)\times2^{23}-\frac{I_x}{2}</script><p>此时的结果已经和代码很像了$\frac{3}{2}(2^7-1-\sigma)\times2^{23}$部分（下面称为公式A）及对应代码中的魔法数字。这时我们就可以计算不同的$\sigma$取值对最终结果的影响。<br>可以看到当$\sigma = 0$的时候，公式A等于<code>0x5f400000</code>已经相当接近原数据了。作者的<code>0x5f3759df</code>相比能让最大误差值更小。当然，还可以找到更优的魔法数字：<code>0x5f375a86</code>，具体可以看看CHRIS LOMONT写的论文《FAST INVERSE SQUARE ROOT》。</p><h2 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y  = * ( <span class="type">float</span> * ) &amp;i;</span><br></pre></td></tr></table></figure><p>第三行比较简单，是将之前计算的结果转回浮点数。</p><h2 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y  = y * ( threehalfs - ( x2 * y * y ) );   <span class="comment">// 1st iteration </span></span><br></pre></td></tr></table></figure><p>这里使用牛顿迭代法进行迭代提高精确度。</p><h3 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h3><p>牛顿迭代法的具体任务是，对于在 $[a,b]$ 上连续且单调的函数$f(x)$，求方程$f(x)=0$的近似解。<br>初始时我们从给定的$f(x)$和一个近似解$x<em>0$开始。<br>假设我们目前的近似解是$x_i$，我们画出与$f(x)$切于点$(x_i,f(x_i))$的直线$l$，将$l$与$x$ 轴的交点横坐标记为$x</em>{i+1}$，那么这就是一个更优的近似解。<br><img src="/posts/850070085/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95.png" class="" title="牛顿迭代法"><br>重复这个迭代的过程。根据导数的几何意义，可以得到如下关系：</p><script type="math/tex; mode=display">f^{'}(x_i)=\frac{f(x_i)}{x_i-x_{i+1}}</script><p>推导可得</p><script type="math/tex; mode=display">x_{i+1}=x_i-\frac{f(x_i)}{f^{'}(x_i)}</script><p>直观地说，如果 $f(x)$ 比较平滑，那么随着迭代次数的增加，$x_i$ 会越来越逼近方程的解。</p><p>下面我们使用牛顿迭代法求解平方根。设$f(x)=x^2-n$，这个方程的解就是$\sqrt{n}$的值。于是我们使用牛顿迭代法求解这个函数的近似值，有：</p><script type="math/tex; mode=display">x_{i+1}=x_i-\frac{x_i^2-n}{2x_i}=\frac{x_i+\frac{n}{x_i}}{2}</script><p>我们尝试用上述公式迭代求解$\sqrt{2}$。这里取近似值为$x_0=1$。有$x_1=1.5$，继续迭代$x_2=1.41\dot{6}$，$x_3=1.4142156862745099$，$x_4=1.4142135623746899$，$x_5=1.414213562373095$。可以发现，在迭代到第五次时就基本相当逼近$\sqrt{2}$的值了。</p><p>对于平方根倒数而言，有可以构造出下面的函数，使得对于输入数$n$有$x=\frac{1}{\sqrt{n}}$这个解。</p><script type="math/tex; mode=display">f(x) = \frac{1}{x^2}-n</script><p>有如下的递推函数</p><script type="math/tex; mode=display">x_{i+1}=x_i-\frac{x_i^{-2}-n}{-2x_i^{-3}}</script><p>整理得</p><script type="math/tex; mode=display">x_{i+1}=x_i(\frac{3}{2}-\frac{n}{2}x^2)</script><p>该公式即代码中所表示的。由此再进行了一步迭代，使结果更精确。而由于初始值已经十分靠近真正结果了，所以这里只进行了一步迭代。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>我们考虑非规格化的情况，如下例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> number = *(<span class="type">float</span>*)&amp;n;</span><br><span class="line">    <span class="built_in">printBits</span>&lt;<span class="type">float</span>&gt;(number);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">float</span> result = <span class="built_in">Q_rsqrt</span>(number);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;real result: &quot;</span> &lt;&lt; <span class="number">1.0f</span> / <span class="built_in">sqrt</span>(number) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> one = <span class="number">0x7fffff</span>;</span><br><span class="line">    <span class="built_in">test</span>(one);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--------------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    one = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">test</span>(one);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000 01111111 11111111 11111111 </span><br><span class="line">number: 1.17549e-38</span><br><span class="line">result: 9.20776e+18</span><br><span class="line">real result: 9.22337e+18</span><br><span class="line">--------------------------------</span><br><span class="line">00000000 00000000 00000000 00000001 </span><br><span class="line">number: 1.4013e-45</span><br><span class="line">result: 1.98178e+19</span><br><span class="line">real result: 2.67137e+22</span><br></pre></td></tr></table></figure><br>可以看到，对于极限情况下的两个非规格化数，使用该快速平方根倒数所得的答案的差距并不明显。</p><p>究其原因，就是对于正非规格化数（2）（3）式都失效了，正非规格化数$x$有（具体可以参考文章<a href="/posts/4203216647/" title="数的编码基础">数的编码基础</a>）：</p><script type="math/tex; mode=display">x=2^{-23}\times 2^{-126}M</script><p>其的阶码编码全是0，所以其转化为整数$I_x$的值为：</p><script type="math/tex; mode=display">I_x=M</script><p>在非规格化数下，规格化浮点数这种位操作与指数的相关性变得不太明显，所以会导致对于这种极限形式的浮点数<code>00000000 00000000 00000000 00000001</code>，该算法和正确答案的差距会比较大。不过如果对精确度的要求不是特别高的话，这种差距也可以视情况接受。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，我们基本搞清楚了快速平方根倒数的原理。可以发现，浮点数的二进制表示数和其对数在表现形式和数值上相当相似，所以对浮点数的二进制表示除以二可以得到一个近似于该浮点数的平方根的值，其中加上的一个魔法数字只是对计算结果的一个优化，甚至不加这个魔法数字，使用我们直接近似计算出的<code>0x5f400000</code>结果也没有太大的差距。<br>同理，这个原理也可以用在计算平方根或者2n次方根上。<br>同时，也需要清楚该快速平方根倒数算法适用于规格化浮点数，对于其他位格式的数需要视情况特殊处理，不能盲目套用。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高效程序员办公工具推荐</title>
      <link href="/posts/1947237942/"/>
      <url>/posts/1947237942/</url>
      
        <content type="html"><![CDATA[<p>本文介绍笔者日常工作中常用的可以提高工作效率的办公软件，持续更新中~<br><span id="more"></span></p><h2 id="InputTip"><a href="#InputTip" class="headerlink" title="InputTip"></a>InputTip</h2><p><a href="https://inputtip.abgox.com/zh-CN/">官网</a><br><a href="https://www.bilibili.com/video/BV17veBzkEU9">介绍视频（B站）</a><br>InputTip 是一个输入法状态管理工具：实时提示(鼠标样式、符号显示) + 窗口自动切换状态 + 快捷键切换状态<br>他可以：</p><ol><li>同步鼠标光标样式<br>根据输入法状态同步修改鼠标样式。通过不同的鼠标样式提示不同的输入法状态。</li><li>多种符号提示<br>输入光标处显示不同的符号，对应不同的输入法状态。可使用图片、方块、文本符号多种符号形式</li><li>管理输入法状态切换<br>激活指定窗口自动切换到指定状态。设置快捷键强制切换指定状态</li></ol><h2 id="Ditto"><a href="#Ditto" class="headerlink" title="Ditto"></a>Ditto</h2><p><a href="https://sabrogden.github.io/Ditto/">官网</a><br>Ditto 是标准 Windows 剪贴板的扩展。它保存放在剪贴板上的每个项目，以便您以后访问其中任何项目。Ditto 允许您保存可以放在剪贴板上的任何类型的信息、文本、图像、html、自定义格式。<br>重要的一点，这个工具可以一直置于窗口最上层，比Windows自带的剪贴板工具好用。</p><h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h2><p><a href="https://www.listary.com/">官网</a><br>Listary 是一个革命性的Windows搜索工具，借助 Listary软件，你可以快速搜索电脑文件、定位文件、执行智能命令、记录访问历史、快速切换目录、收藏常用项目等。<br>Listary为 Windows 传统低效的文件打开/保存对话框提供了便捷、人性化的文件（夹）定位方式，同时改善了常见文件管理器中文件夹切换的效率。<br>任意界面双击 “Ctrl” 可打开软件搜索框进行全盘搜索。</p><h2 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h2><p><a href="https://cn-snipaste.com/">官网</a><br>Snipaste是一款功能强大且极具特色的截图软件。 基础截图功能丰富，适用于大部分的截图需求，简单操作即可获得想要的截图方案。<br>这个软件的截图可以在桌面置顶显示，相当于一个快捷的便利贴功能。不过现在飞书、QQ的截图功能也有类似的功能，并且还有录屏、提取图片文字的功能了。是否使用这个软件看个人习惯吧。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通讯基础-粘包与半包</title>
      <link href="/posts/730200892/"/>
      <url>/posts/730200892/</url>
      
        <content type="html"><![CDATA[<h2 id="粘包与半包的定义"><a href="#粘包与半包的定义" class="headerlink" title="粘包与半包的定义"></a>粘包与半包的定义</h2><p>我们设定发送端希望发送的两个数据分别为$A$和$B$，在生成发送数据包时，由于某些原因，$B$数据被拆成了两份$B_1$和$B_2$，并且$B_1$和$A$数据一起组成了一个网络数据包$F_1$进行了发送，$B_2$单独作为一个网络数据包$F_2$进行发送。这时，网络数据包$F_1$中数据$A$和$B$“粘连”在一起，就被称为粘包。网络数据包$F_2$中数据$B$不完整，就被称为“半包”。<br>可以想到，在不做任何处理的情况下，接收端收到的网络数据包$F_1$，是无法将数据$A$辨识并解析出来的，在接受了$F_1$和$F_2$数据包后，也无法将数据$B$提取并合并成完整的数据。</p><h2 id="粘包与半包的出现原因"><a href="#粘包与半包的出现原因" class="headerlink" title="粘包与半包的出现原因"></a>粘包与半包的出现原因</h2><p>粘包与半包常在TCP传输中出现，不过事实上，如果你的网络协议具有分包组包的功能，那么就会出现半包问题，如果具有将多个小数据包合并成一个大数据包的功能，那么就会出现粘包。<br>分包组包指，当需要发送的数据量过大，或者网络条件限制（如带宽限制、丢包率高等）时，为了确保数据的完整性和发送效率，通常会将大块数据分割成多个小数据包进行发送，这就是所谓的分包。每个数据包都有一个唯一的序列号，以便接收端能够按照正确的顺序重新组合这些数据包，接受端组合数据包的过程就是组包。<br>所以，在应用层实现了类似TCP相关优化的UDP也会出现粘包与半包问题。这里我们先只讨论TCP的情况。</p><p>至于为什么TCP会出现粘包半包的情况，是因为TCP底层的 Nagle 算法，详细可以阅读<a href="/posts/3544708607/" title="游戏中的网络通信（二）TCP协议详解">TCP报文发送时机</a>。简单的说，该算法是TCP为了提高网络吞吐量的办法，为了提高一个包体中的有效数据内容占比。这也是TCP有时被称为面向数据流的原因。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="禁用TCP的Nagle算法"><a href="#禁用TCP的Nagle算法" class="headerlink" title="禁用TCP的Nagle算法"></a>禁用TCP的Nagle算法</h3><p>既然Nagle算法造成了粘包半包问题，那么可以设置TCP_NODELAY来禁用TCP的Nagle算法。HTTP就是这样做的。<br>Nagle算法会引发几种HTTP性能问题。首先，小的HTTP报文可能无法填满一个分组，可能会因为等待哪些永远不会到达的额外数据而产生时延。其次，Nagle算法与延迟确认之间的交互存在问题，Nagle算法会阻止数据的发送，直到有确认分组到达为止。但确认分组自身会被延迟确认算法延迟100-200ms，当使用管道化连接时这些问题可能会更加严重，因为客户端可能会有多条报文要发送给同一个服务器，而且不希望有时延存在。<br>禁用Nagle算法对于会降低网络吞吐量，在游戏网络开发中并不常见。</p><h3 id="固定包长"><a href="#固定包长" class="headerlink" title="固定包长"></a>固定包长</h3><p><strong>即每个协议包的长度都是固定的。</strong> 比如我们可以规定协议包的大小是64个字节，接收端每次取64个字节即可还原出原数据，缓冲区不足64字节则等待。<br>该方法不灵活，对于不足64字节的数据，需要用格外的空数据补足。而如果超出了64字节，则还需要格外的分包处理逻辑。一般也不常用。</p><h3 id="指定包的结束标志"><a href="#指定包的结束标志" class="headerlink" title="指定包的结束标志"></a>指定包的结束标志</h3><p><strong>即用一个特殊符号标记一个数据包结束。</strong> 比如，我们熟悉的FTP协议，发邮件的SMTP协议，一个命令或者一段数据后面加上”\r\n”（即所谓的 CRLF）表示一个包的结束。对端收到后，每遇到一个”\r\n”就把之前的数据当做一个数据包。<br>这种协议一般用于一些包含各种命令控制的应用中，其不足之处就是如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。</p><h3 id="包体中包含消息长度信息"><a href="#包体中包含消息长度信息" class="headerlink" title="包体中包含消息长度信息"></a>包体中包含消息长度信息</h3><p>这是常见且最灵活的处理粘包半包的方式。<strong>他将需要发送的数据分为两部分，一部分是描述该数据长度的信息，另一部分则是数据本身。</strong> 接受端收到消息后会通过长度信息知道该部分数据的大小，这自然的进行了数据之间的隔离。</p>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通讯（六）浮点数确定性</title>
      <link href="/posts/343241564/"/>
      <url>/posts/343241564/</url>
      
        <content type="html"><![CDATA[<p>以下都是在IEEE 754-2019浮点数标准下探讨，按其他标准设计的浮点数不在探讨范围中。IEEE 754相关内容在<a href="/posts/4203216647/" title="数的编码基础">浮点数的编码 (IEEE 754)</a>中详细介绍。<br>我常常在各种技术文章里看到类似，说由于浮点数精度原因，在网络同步中不会使用浮点数，转而会使用定点数代替浮点数的说法。因此，本文对浮点数的确定性问题进行详细探讨。<br><span id="more"></span></p><h2 id="浮点数的表示的确定性"><a href="#浮点数的表示的确定性" class="headerlink" title="浮点数的表示的确定性"></a>浮点数的表示的确定性</h2><p>IEEE 754规定了五种浮点基本格式：</p><ul><li>三种二进制格式，编码长度分别为32/64/128 bits</li><li>两种十进制格式，编码长度分别为64/128 bits</li></ul><p>其中，大部分编译器实现了符合标准的单精度浮点数和双精度浮点数（32位和64位二进制浮点格式）。以c++举例，有<code>float</code>、<code>double</code>、<code>long double</code>三种基础浮点类型。其中<code>long double</code>的可移植性最差。有些系统不直接支持<code>long double</code>，在这些系统上，它的大小与<code>double</code>类型相同。比如<code>long double</code> 在 MSVC 下是 64 位，在 GCC/Clang 下是 80 位。<br>设备的字节序也会影响浮点数的解析，如x86为小端序，PowerPC为大端序。若不显式处理，跨设备传输二进制浮点数据时会发生解析错误。</p><p>可见，对于实现了IEEE 754标准的编译器而言，基本可以保证浮点数编码的统一性。浮点数真正不可靠的地方在于其运算上。</p><h2 id="浮点数的运算的确定性"><a href="#浮点数的运算的确定性" class="headerlink" title="浮点数的运算的确定性"></a>浮点数的运算的确定性</h2><h3 id="硬件影响的确定性"><a href="#硬件影响的确定性" class="headerlink" title="硬件影响的确定性"></a>硬件影响的确定性</h3><p>在不同平台上，浮点运算单元的运算格式运算精度可能不相同，比如 IA-32 上的浮点运算单元仅支持80位双扩展浮点格式。所以对于不同格式精度的硬件，在进行运算时会出现不同的舍入问题。同时，以IA-32为例，在进行标准浮点算术运算之前，它必须将不同格式的浮点数转换为本机格式，最后则将结果转换回标准格式。由于中间结果会存储在内存中以供以后使用，因此也需要进行舍入操作，这也是影响浮点确定性的原因之一。<br>不同的CPU会有不同的FPU可供编译器选择。比如一些CPU会支持使用有SSE指令集进行浮点运算。如下参考段落所写，SSE采用128位的寄存器进行运算，和上述使用80位寄存器运算的结果也会出现舍入精度差异。</p><blockquote><p>SSE 是什么？<br>SIMD（Single Instruction Multiple Data）是单指令多数据技术，目前Intel处理器支持的SIMD技术包括MMX，SSE，AVX。<br>SSE（Stream SIMD Extentions，数据流单指令多数据扩展）是英特尔继MMX（Multi Media eXtension，多媒体扩展指令集）之后推出的新一代CPU指令集。MMX提供了8个64bit的寄存器进行SIMD操作，SSE系列提供了8个128bit的寄存器进行SIMD操作。而最新的AVX指令则支持256bit的SIMD操作。</p></blockquote><p>x87 FPU存在一个 control word 寄存器，用来控制浮点计算的相关行为从而导致不同结果，这个寄存器可能被其他程序设置，导致两次相同平台的计算结果出错。</p><blockquote><p>x87 FPU Control Word<br>The 16-bit x87 FPU control word controls the precision of the x87 FPU and rounding method used.<br>It also contains the x87 FPU floating-point exception mask bits. The control word is cached in the x87 FPU control<br>register. The contents of this register can be loaded with the FLDCW instruction and stored in memory with the<br>FSTCW/FNSTCW instructions.</p></blockquote><p>由于平台对浮点数设置和优化不同，所以浮点数的运算在不同硬件平台层面上会有差异。</p><h3 id="IEEE-754-影响确定性的特性"><a href="#IEEE-754-影响确定性的特性" class="headerlink" title="IEEE 754 影响确定性的特性"></a>IEEE 754 影响确定性的特性</h3><p>IEEE 754 标准具有一些特殊功能，它们是在平台之间移植浮点代码时出现问题的主要原因。以下部分将讨论这些功能。</p><ol><li>NaN（非数）<br><a href="/posts/4203216647/" title="数的编码基础">浮点数的编码 (IEEE 754)</a>中介绍了两种NaN形式，qNaN和sNaN。<br>标准没有定义统一的方法来检查给定的浮点数是否是NaN。将 NaN 转换为字符串的结果也不是标准化的，并且因平台而异。同样，将 NaN 转换为整数会产生未定义的结果。</li><li>Infinity（无穷大）<br>与 NaN 一样，将无负大转换为字符串的结果不是标准化的，并且因平台而异。将无穷大转换为整数的结果也是未定义的。</li><li>符号零<br>在浮点数编码中，0由于不同符号位，存在<code>+0</code>和<code>-0</code>两个表示0的编码，但是比较是相等的。</li><li>非规格化值<br>非规格化数提供了用于表示那些非常接近于$0.0$的数的功能。它们提供了一种属性，称为逐渐溢出（gradual underflow），其中，可能的数值分布均匀地接近于$0.0$。<br>但是非规格化数很难实现，尤其是在硬件中，因此并非所有系统都实现它们。这就是为什么即使两个系统都使用 IEEE 754 标准，相同的计算也可能在不同系统上导致不同结果的原因之一。</li><li><p>舍入<br>每当运算的结果不能精确表示为浮点数时，就会发生舍入。IEEE 745 两类舍入方向属性，分别是最近舍入和定向舍入。<br>最近舍入根据存在两个最近浮点数时的选择方式分为roundTiesToEven（选择偶数）和roundTiesToAway（选择绝对值更大的数），两种舍入属性都会在当无限精度结果绝对值大于等于$b^{e<em>{max}}\times(b-1/2\times b^{1-p})$时舍入到无穷。其中b是基数，2或10，对应二进制或十进制，$e</em>{max}$是最大指数值，p是有效数字位数，也就对应着精度。<br>定向舍入根据舍入方向分为roundTowardPositive（向正无穷方向）、roundTowardNegative（向负无穷方向）、roundTowardZero（向零方向）。</p><ul><li>roundTiesToEven：舍入到最接近无限精度结果的浮点数；如果存在两个最接近的浮点数，舍入到最低有效数字为偶数的那一个；如果两个最接近的浮点数的最低有效数字都是奇数，则舍入到绝对值更大的那个数（这种情况可能发生在十进制格式的单位精度，例如将9.5舍入时，9和$1\times10^1$的最低位都是奇数，这个时候应该舍入到 $1\times10^1$）</li><li>roundTiesToAway：舍入到最接近无限精度结果的浮点数；如果存在两个最接近的浮点数，舍入到绝对值更大的那个数，也就是朝向远离零点的方向舍入</li><li>roundTowardsPositive：舍入到最接近且不小于无限精度结果的浮点数（可能是正无穷），也就是朝向正无穷方向舍入</li><li>roundTowardsNegative：舍入到最接近且不大于无限精度结果的浮点数（可能是负无穷），也就是朝向负无穷方向舍入</li><li>roundTowardsZero：舍入到最接近且绝对值不大于无限精度结果绝对值的浮点数，也就是朝向零点方向舍入</li></ul><p>在C++中没有标准化的接口来设置或查询当前的舍入模式，许多平台在库级别也根本没有这样的接口，浮点数的舍入可以认为在软件应用层几乎是无法控制的。浮点数的舍入的区别是其不可确定的一个相当大的原因。</p></li><li><p>异常<br>IEEE 754 标准还指定了异常机制，其中异常将导致调用异常处理程序。此外，还通过相应地设置值全局状态标志来报告异常。该标准定义了五个异常类。</p><ul><li>上溢</li><li>下溢</li><li>除0</li><li>无效操作</li><li>不精确</li></ul><p>相同的是，在C++中同样没有相关标准化接口来设置异常处理程序或测试状态标志。</p></li></ol><h3 id="IEEE-754-标准未解决的问题"><a href="#IEEE-754-标准未解决的问题" class="headerlink" title="IEEE 754 标准未解决的问题"></a>IEEE 754 标准未解决的问题</h3><p>IEEE 754 没有规定如何实现 <code>sin()、cos()、exp()</code> 等超越函数。<br>因此，对于相同的参数，这些函数在不同平台上返回的结果可能并不完全相同。这是在不同平台上对同一表达式获得不相同结果的另一个原因。<br>该标准也没有指定如何实现从十进制浮点值到其二进制表示的转换，反之亦然。特别是 NaN 和无负大在平台之间的字符串表示不同。使用 <code>pow()</code> 函数时也要小心。在某些系统上，它仅适用于正指数和整数指数。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>如果使用使用相同编译器构建的可执行文件，在具有相同体系结构的计算机上运行，并执行一些特定于平台的技巧，则可以获得跨多台计算机的浮动计算的确定性结果。</li><li>用 C 或 C++ 编写任意浮点代码并期望它在不同的编译器或架构中给出完全相同的结果，甚至在调试和发布版本中给出相同的结果，这是非常天真的。</li><li>通过大量工作，可以通过使用编译器“严格”IEEE 754 兼容模式并限制您使用的浮点运算集，从不同的编译器或不同的机器架构中获得完全相同的浮点结果。这通常会导致浮点性能显着降低。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>IEEE Standard for Floating-Point Arithmetic (IEEE 754-2019)</li><li><a href="https://gafferongames.com/post/floating_point_determinism/">Floating Point Determinism</a></li><li>Cross-Platform Issues With Floating-Point Arithmetics in C++, Günter Obiltschnig, Applied Informatics Software Engineering GmbH, ACCU Conference 2006</li><li><a href="https://coolshell.cn/articles/11235.html">一个浮点数跨平台产生的问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
          <category> 网络同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 帧同步 </tag>
            
            <tag> 状态同步 </tag>
            
            <tag> 浮点数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数的编码基础</title>
      <link href="/posts/4203216647/"/>
      <url>/posts/4203216647/</url>
      
        <content type="html"><![CDATA[<h2 id="数的二进制表示"><a href="#数的二进制表示" class="headerlink" title="数的二进制表示"></a>数的二进制表示</h2><p>对于任意一个$N$进制数而言，有下面的计算公式：</p><script type="math/tex; mode=display">(S)_N = \sum_{i=n-1}^{-m}k_iN^{i-1}</script><p>其中，$n$ 为小数点前的数字位数（从1开始计数），$m$ 为小数点后的数字位数（从1开始计数）,$k_i$ 为对应第$i$位数。<br>比如:<br>对于十进制数 114.514 有： </p><script type="math/tex; mode=display">(11.4)_{10} = 1 \times 10^1+1\times10^0+4\times10^{-1}     = \sum_{i=1}^{-1}k_i10^{i-1}</script><p>对于二进制数 101.01 有：</p><script type="math/tex; mode=display">\begin{aligned}(10.01)_2 &= 1 \times 2^{1}+0\times2^{0}+0\times2^{-1}+1\times2^{-2} \\ &= \sum_{i=1}^{-2}k_i2^{i-1} \\&= (5.25)_{10}\end{aligned}</script><p>对于十六进制数 A2.F 有：</p><script type="math/tex; mode=display">(A2.F)_{16} = 10\times16^{1}+2\times16^{0}+15\times16^{-1} = (162.9375)_{10}</script><p>由于二进制表示的数总是位数太长，人们就常用八进制或十六进制来书写，而且八进制或十六进制表示的数据信息很容易转换成二进制表示。这就是一般计算机工作者普遍使用八进制或十六进制的原因。<br>由于数$2^3=8,2^4=16$所以一位八进制数所能表示的数值恰好相当于三位二进制数能表示的数值，而一位十六进制数与四位二进制数能表示的数值正好相当，因此八进制、十六进制与二进制数之间的转换极为方便。例如</p><script type="math/tex; mode=display">(67.731)_8=(110111.111011001)_2</script><script type="math/tex; mode=display">(3AB4)_{16} = (0011101010110100)_2</script><p>反之，从二进制数转换成八进制数时，只要从小数点开始，分别别向左右两边把3位二进制数码划为一组，最左和最右一组不足3位用0补充，然后每组用一个八进制数码代替即成，例如</p><script type="math/tex; mode=display">(11111101.01001111)_2=(375.236)_{8}</script><p>二进制数转换成十六进制数与此类似，只不过是四位二进制数码分为一组，例如</p><script type="math/tex; mode=display">(1111101.01001111)_2 = (7D.4F)_{16}</script><h2 id="数的机械码编码"><a href="#数的机械码编码" class="headerlink" title="数的机械码编码"></a>数的机械码编码</h2><p>首先定义真值就是希望表示的数据的二进制形式。</p><h3 id="无符号整数的编码"><a href="#无符号整数的编码" class="headerlink" title="无符号整数的编码"></a>无符号整数的编码</h3><p>在精度范围内，无符号数的编码就是该数的真值，这里用一个函数$U_w(x)$来表示$w$长度的数x的无符号数编码。<br>比如32位无符号整型数 114514：</p><script type="math/tex; mode=display">U_32(114514)=(0000 0000 0000 0001 1011 1111 0101 0010)_2=(0001 BF52)_{16}</script><p>$w$位的无符号数的范围是$[0,2^{w}-1]$。对应$w$位数全为0和全为1的情况。</p><h3 id="有符号整数的编码"><a href="#有符号整数的编码" class="headerlink" title="有符号整数的编码"></a>有符号整数的编码</h3><h4 id="原码编码"><a href="#原码编码" class="headerlink" title="原码编码"></a>原码编码</h4><p><strong>在精度范围内，原码就是符号位拼接上真值的绝对值</strong>。符号位为1表示值为负，为0表示值为正。<br>比如在8位格式表示下的原码：</p><script type="math/tex; mode=display">114 = [0111 0010]_{原}</script><script type="math/tex; mode=display">-114 = [1111 0010]_{原}</script><script type="math/tex; mode=display">0 = [0000 0000]_{原} or [1000 0000]_{原}</script><script type="math/tex; mode=display">127 = [0111 1111]_{原}</script><script type="math/tex; mode=display">-127 = [1111 1111]_{原}</script><p>$w$位原码所能表示的范围是$[-(2^{w-1}-1),2^{w-1}-1]$<br>如果使用原码来做减法，可以发现：</p><script type="math/tex; mode=display">\begin{aligned} 1 - 1 &= 1 + (-1) \\        &= [0000 0001]_{原} + [1000 0001]_{原} \\        &= [1000 0010]_{原}  \\        &= -2\end{aligned}</script><p>如果让符号位参与计算，就会发现计算结果是错误的，那么如果要进行原码之间的计算，就需要单独处理符号位的部分，这是耗时且不统一的。为了解决原码做减法出现的问题，出现了反码。</p><h4 id="反码编码"><a href="#反码编码" class="headerlink" title="反码编码"></a>反码编码</h4><p><strong>反码主要用于表示负数。对于正数，其反码与其原码相同，对于负数，反码是将原码除符号位外的所有位取反。</strong><br>比如在8位格式表示下的反码：</p><script type="math/tex; mode=display">114 = [0111 0010]_{反}</script><script type="math/tex; mode=display">-114 = [1000 110]_{反}</script><script type="math/tex; mode=display">0 = [1111 1111]_{反} = [0000 0000]_{反}</script><script type="math/tex; mode=display">127 = [0111 1111]_{反}</script><script type="math/tex; mode=display">-127 = [1000 0000]_{反}</script><p>$w$位反码所能表示的范围是$[-(2^{w-1}-1),2^{w-1}-1]$和原码一致。<br>使用反码来实现的减法如下：</p><script type="math/tex; mode=display">\begin{aligned}  1 - 1 &= 1 + (-1) \\        &= [0000 0001]_{反} + [1111 1110]_{反} \\        &= [1111 1111]_{反} \\        &= [1000 0000]_{原} \\        &= 0\end{aligned}</script><p>发现用反码计算减法，结果的真值部分是正确的。但是我们考虑反码的跨0运算情况：</p><script type="math/tex; mode=display">\begin{aligned}2 - 1 &= [0000 0010]_{反} + [1111 1110]_{反}      &= [0000 0000]_{反}      &= 0 ？\end{aligned}</script><p>反码在跨0运算时，会出错。其次，还有<code>0</code>这个特殊的数值，虽然人们理解上<code>+0</code>和<code>-0</code>是一样的，但是0带符号是没有任何意义的，而且会有$[0000 0000]<em>{原}$和$[1000 0000]</em>{原}$两个编码表示0。为了解决了0的符号问题以及0的两个编码问题，出现了补码。</p><h4 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h4><p>最常见的有符号数的计算机表示方式就是补码形式。补码编码的最高有效位（MSB）会被解释为符号位（也叫负权）。<strong>补码的表示方法是，正数的补码就是其原码，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。</strong><br>以8位格式的补码为例。</p><script type="math/tex; mode=display">114 = [0111 0010]_{补}</script><script type="math/tex; mode=display">-114 = [1000 1110]_{补}</script><script type="math/tex; mode=display">0 = [0000 0000]_{补}</script><script type="math/tex; mode=display">127 = [0111 1111]_{补}</script><script type="math/tex; mode=display">-127 = [1000 0001]_{补}</script><script type="math/tex; mode=display">-128 = [1000 0000]_{补}</script><p>这里由于补码的0只有一个编码表示，所以将原来的<code>-0</code>（$[1000 0000]_{原}$）拓展为负数最高位。<br>$w$位补码所能表示的范围是$[-(2^{w-1}),2^{w-1}-1]$<br>对于补码的减法：</p><script type="math/tex; mode=display">\begin{aligned}    -127 - 1 &= [1000 0001]_{补} + [1111 1111]_{补} \\            &= [1000 0000]_{补}\\            &= -128\end{aligned}</script><p>上面的公式第二行由于进位被截断，所以表示出来就是原码的<code>-0</code>，在补码中被定义为<code>-128</code>。</p><h4 id="深入补码"><a href="#深入补码" class="headerlink" title="深入补码"></a>深入补码</h4><p>接下来我们考虑这样一个事情，为什么计算机的有符号计算普遍使用补码？<br>我们考虑3位编码的情况：</p><div class="table-container"><table><thead><tr><th>二进制表示</th><th>原码</th><th>原码%8</th><th>反码</th><th>反码%8</th><th>补码</th><th>补码%8</th><th>实际值</th></tr></thead><tbody><tr><td>000</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>001</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>010</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>011</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>100</td><td>0</td><td>0</td><td>-3</td><td>5</td><td>-4</td><td>4</td><td>4</td></tr><tr><td>101</td><td>-1</td><td>7</td><td>-2</td><td>6</td><td>-3</td><td>5</td><td>5</td></tr><tr><td>110</td><td>-2</td><td>6</td><td>-1</td><td>7</td><td>-2</td><td>6</td><td>6</td></tr><tr><td>111</td><td>-3</td><td>5</td><td>0</td><td>0</td><td>-1</td><td>7</td><td>7</td></tr></tbody></table></div><p>可以发现，补码在<strong>模运算</strong>上有优秀的数学本质。补码的模$2^n$(n为编码位数)和二进制表示的实际值统一。<br>在数学意义上，加减法就统一为模加法：</p><script type="math/tex; mode=display">A-B \equiv A + (2^N - B) \equiv A - B (mod 2^N)</script><p>在硬件实现上，可以直接丢弃溢出位（即自动取模），无需区分正负符号位。</p><h3 id="小数的编码"><a href="#小数的编码" class="headerlink" title="小数的编码"></a>小数的编码</h3><h3 id="定点数的编码"><a href="#定点数的编码" class="headerlink" title="定点数的编码"></a>定点数的编码</h3><p>顾名思义，定点数，是小数点位置确定的数，笔者没有看到一个关于定点数实现的公认标准方法。以下只是总结其他人的定点数实现，定点数虽然精确，但运算速度和表示精度上远不及浮点数，一般会在一些对计算结果精度要求严格的业务下使用。<br>使用定点数的场景下需要事先约定好小数点位置，以及小数的表示方式。比如在8位精度下，约定前4位使用4位有符号整型表示小数的整数部分及小数正负，后4位使用4位无符号整型表示小数部分。在这种约定下，因为是用整型数表示小数，而4位无符号整型的范围是$[0,15]$，如果用来表示量位精度的小数的话，对于$(0.15,1)$范围内的小数将无法进行表示，所以4位无符号整型只能表示一位精度的小数，即表示[0,9]。<br>除了上述表示方式外，还可以使用标准二进制的方式表示小数部分，如<a href="#数的二进制表示">数的二进制表示</a>所讲的，假设我们有3位可以用来表示小数，那么可以表示的值为：</p><div class="table-container"><table><thead><tr><th>二进制表示</th><th>实际值</th></tr></thead><tbody><tr><td>.000</td><td>0.0</td></tr><tr><td>.001</td><td>0.125</td></tr><tr><td>.010</td><td>0.25</td></tr><tr><td>.011</td><td>0.375</td></tr><tr><td>.100</td><td>0.5</td></tr><tr><td>.101</td><td>0.625</td></tr><tr><td>.110</td><td>0.75</td></tr><tr><td>.111</td><td>0.875</td></tr></tbody></table></div><p>当然如果按精度看的话，位数一致的前提下，两种方式所能表示的十进制精度是一致的。<br>还有一些语言会使用特殊的算法，用浮点数的形式，模拟定点数的精确性（比如C#语言中的decimal类型），后续有机会会进行介绍。</p><h3 id="移码编码"><a href="#移码编码" class="headerlink" title="移码编码"></a>移码编码</h3><p>在介绍IEEE 754 浮点数标准前，先介绍一下移码编码。<br><strong>移码用于浮点数的阶码，移码是在数X上增加一个偏移量来定义的</strong>,这个偏移量并不恒定，如果机器字长为n，标准偏移量为$2^{n-1}$,但是在IEEE 754标准中，偏移量是$2^{n-1}-1$，这也是移码。下面以标准移码举例。若X是整数，则$X_移=2^{n-1}+X$。以8位格式的移码为例。</p><script type="math/tex; mode=display">114 = [1111 0010]_{移}</script><script type="math/tex; mode=display">-114 = [0000 1110]_{移}</script><script type="math/tex; mode=display">0 = [1000 0000]_{移}</script><script type="math/tex; mode=display">-128 = [0000 0000]_{移}</script><p>这里需要格外说明一点，为什么需要特别创造出一个移码来作为浮点数阶码的编码方式？用补码不行吗？<br>事实上，如果希望自己实现一个新的浮点数类型，用补码代替移码也完全可以。至于为什么IEEE 754使用移码而不是补码，我们首先需要思考，在使用科学计算法进行加减运算时，我们到底是在做什么？<br>首先需要比较阶码大小，然后计算出阶码之间的差值，进行浮点数的对阶（小阶向大阶对齐），然后计算新的尾数。<br>在使用补码的情况下，进行阶码的比较需要格外对符号位进行比较，对阶时计算阶差及补码相减。而在使用移码的情况下，比较器可以直接按无符号数规则进行比较，且计算阶差时，移码相减后偏移量自动抵消，结果即为真值阶差。<br>因此，移码相比于补码在对阶阶段有格外的速度优势，IEEE 754标准因此采用移码作为阶码的编码方式。</p><h3 id="浮点数的编码-IEEE-754"><a href="#浮点数的编码-IEEE-754" class="headerlink" title="浮点数的编码 (IEEE 754)"></a>浮点数的编码 (IEEE 754)</h3><p><a href="#定点数的编码">定点数的编码</a>对于非常大或非常小的数不能有效表示，比如$5\times 2^{100}$或者$5\times2^{-100}$。<br>IEEE 754 浮点数标准用$V=(-1)^s\times M\times 2^{E}$的形式来表示一个数。</p><ul><li>符号（sign）s决定这数是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理。</li><li>尾数（significand） M是一个长度为p的$d_0d_1d_2…d_{p-1}$表示的字符串，其中$d_i$取值为0或1。</li><li>阶码（exponent）E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。</li></ul><p>下图给出了将这三个字段装进字中的常见格式，分别是32位表示的单精度浮点数和64位表示的双精度浮点数：<br><img src="/posts/4203216647/%E6%A0%87%E5%87%86%E6%B5%AE%E7%82%B9%E6%A0%BC%E5%BC%8F.png" class="" title="标准浮点格式"></p><p>根据<code>exp</code>的值，被编码的值可以分成三种不同的情况。如下图所示：<br><img src="/posts/4203216647/%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E5%80%BC%E7%9A%84%E5%88%86%E7%B1%BB.png" class="" title="单精度浮点数值的分类"><br>可见标准将阶码的最大值（全为1）和最小值（全为0）保留作为特殊用途使用的标记。所以对于一个$w$位的移码，在IEEE 754标准中的偏移值是$2^{w-1}-1$，实际可以表示的范围会比补码$[-(2^{w-1}),2^{w-1}-1]$少最小值两位，即$[-(2^{w-1}-2),2^{w-1}-1]$，下面详细介绍一下图中的数值分类。</p><ul><li><p>情况一：规格化的值<br>这是最普遍的情况。当<code>exp</code>的位模式既不全为0（数值0），也不全为1（单精度数值为255，双精度数值为2047）时，都属于这类情况。在这种情况中，阶码字段被解释为以偏置（$biased$）形式表示的有符号整数。也就是说，阶码的值是$E=e-Bias$，其中$e$是无符号数，而$Bias = 2^{k-1}-1$的偏置值，即偏移量为$Bias$的移码。由此产生指数的取值范围，对于单精度是$[-126,+127]$，而对于双精度是$[-1022,+1023]$。<br>小数字段<code>frac</code>被解释为描述小数值$f$，其中$0\leq f&lt;1$，其二进制表示为$0.f_{n-1}…f_1f_0$，也就是二进制小数点在最高有效位的左边。尾数定义为$M=1+f$。有时，这种方式也叫做隐含的以1开头的（implied leading 1）表示，因为我们可以把$M$看成一个二进制表达式为$1.f_{n-1}f_{n-2}…f_0$的数字。既然我们总是能够调整阶码$E$，使得尾数$M$在范围$1\leq M&lt;2$之中（假设没有溢出），那么这种表示方法是一种轻松获得一个额外精度位的技巧。既然第一位总是等于1，那么我们就不需要显式地表示它。</p></li><li><p>情况二：非规格化的值<br>当阶码域为全0时，所表示的数是非规格化形式。在这种情况下，<strong>阶码值是$E=1-Bias$其中$Bias$是一个等于$2^{k-1}-1$的值</strong>（移码的偏移量大小），而尾数的值是$M=f$，也就是小数字段的值，不包含隐含的开头的1。<br>非规格化数有两个用途。</p><ol><li>它们提供了一种表示数值0的方法，因为使用规格化数，我们必须总是使$M≥1$，因此我们就不能表示0。实际上，$+0.0$的浮点表示的位模式为全0：符号位是0，阶码字段全为0（表明是一个非规格化值），而小数域也全为0，这就得到$M=f=0$。令人奇怪的是，当符号位为1，而其他域全为0时，我们得到值$-0.0$。根据IEEE的浮点格式，值$+0.0$和$-0.0$在某些方面被认为是不同的，而在其他方面是相同的。</li><li>非规格化数的另外一个功能是表示那些非常接近于$0.0$的数。它们提供了一种属性，称为逐渐溢出（gradual underflow），其中，可能的数值分布均匀地接近于$0.0$。</li></ol></li><li><p>情况三：特殊值<br>最后一类数值是当指阶码全为1的时候出现的。当小数域全为0时，得到的值表示无穷，当符号位$s=0$时是$+\infty$，或者当$s=1$时是$+\infty$。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。当小数域为非零时，结果值被称为”$NaN$”，即不是一个数（Not a Number）的缩写。一些运算的结果不能是实数或无穷，就会返回这样的$NaN$值，比如当计算$\sqrt{-1}$或$\infty - \infty$时。在某些应用中，表示未初始化的数据时，它们也很有用处。<br>所有浮点操作都应该支持两种不同的NaN：sNaN和qNaN。sNaN提供不属于 IEEE 754 标准规定范围的未初始化变量的表示以及算术增强（例如无穷的复杂映射或者极宽的表示范围）；qNaN应该由实现者自行决定提供从无效或不可用数据和结果带来的回溯诊断信息。为了方便传播NaN中包含的诊断信息，应该尽可能多地预先准备这些信息。<br>在二进制编码中，NaN的符号位S为0或1，阶码E的所有位设为1。qNaN尾数T的第一位(d1)为1，sNaN尾数T的第一位为0。如果尾数T的第一位为0，则尾数T的其他一些位必须非零，以区分NaN和无穷大。sNaN变为qNaN时应该将尾数T的第一位d1设置为1，尾数T的剩余位不变，因为尾数T的剩余位的负载可能包含着诊断信息。</p></li></ul><p>现在我们假设一个8位浮点数格式来举例，其中有4位阶码、3位小数位还有1位符号位。<br>对于非规格化数：</p><script type="math/tex; mode=display">[0 0000 000]_f = 2^{-6} \times 0 = 0.0</script><script type="math/tex; mode=display">[0 0000 001]_f = 2^{-6} \times 2^{-3} = 0.001953125</script><script type="math/tex; mode=display">[1 0000 111]_f = -1 \times 2^{-6} \times (2^{-1}+2^{-2}+2^{-3}) = -0.013671875</script><p>可以看到，对于非规格化数而言，阶码就是$1-Bias = 1 - (2^{4-1}-1) = -6$，而且不会执行隐含1的开头优化，尾数就是小数点后的数。<br>对于规格化数：</p><script type="math/tex; mode=display">[0 0001 000]_f = 2^{-6} \times 1 = 0.015625</script><script type="math/tex; mode=display">[0 0110 110]_f = 2^{-1} \times (1+2^{-1}+2^{-2})=0.875</script><script type="math/tex; mode=display">[0 0111 000]_f = 2^{0} \times 1 = 1</script><script type="math/tex; mode=display">[0 1110 111]_f = 2^{7} \times (1+2^{-1}+2^{-2}+2^{-3})=240.0</script><p>对于无穷大数：</p><script type="math/tex; mode=display">[0 1111 000]_f = \infty</script><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《深入理解计算机系统（第三版）》兰德尔E.布莱恩特、大卫R.奥哈拉伦</li><li>《计算机组成原理（第七版）》戴志涛、白中英</li><li><a href="https://zhuanlan.zhihu.com/p/118432554">《原码、反码、补码》</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成 </category>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 编码 </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通讯（五）网络同步方案概览</title>
      <link href="/posts/3900935936/"/>
      <url>/posts/3900935936/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>同步方案是联网游戏中才有的概念，​​网络同步的核心目的是确保所有玩家在各自客户端上感知的游戏状态高度一致​​，同时优化延迟、防止作弊并提升整体体验。<br>在当前网络游戏中，网络同步解决方案目前公认并且常用的有两种，即状态同步和锁步帧同步（lockstep），但是除此之外，还分类出了实时广播同步、快照同步、状态帧同步等方案。这些方案不互相排斥，可以混合使用。这里对提到的这些方案都进行介绍。<br><span id="more"></span><br>具体来说，网络同步有多个重要目的：</p><ol><li>为了保持游戏状态的一致性。比如在MMO游戏中，当一个玩家击败怪物获得宝物时，其他玩家需要立即知道这件事，否则就会出现两个玩家都以为自己获得了宝物的混乱局面。这种一致性体现在位置、生命值、物品状态等多个方面。</li><li>为了提供流畅的游戏体验。网络延迟是不可避免的，同步技术如客户端预测可以让玩家在等待服务器响应时也能有流畅的操作体验。如果同步不好，玩家会遇到角色瞬移、动作延迟等问题。</li><li>防止作弊。服务器通过权威验证可以防止玩家篡改本地客户端数据作弊。如果客户端可以随意修改状态而不被服务器检查，游戏就很容易被破解。</li><li>优化性能。通过差异化同步等技术，只传输变化的数据而不是完整状态，可以大大减少网络带宽占用。这对大规模多人在线游戏特别重要。</li><li>同步技术还能支持跨平台游戏、减少服务器负载、便于数据分析等。</li></ol><h2 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h2><p>状态同步是指使角色的每个状态在某一段时间下的行为可以根据数据进行预测，除非状态被改变，否则相同的状态数据得到的是相同的个体状态结果，这样，角色实体的行为就可以通过状态切换来模拟表现画面。<strong>状态同步的核心是同步发生变化的状态。</strong><br>比如，一个玩家角色的位置从A点移动到B点，他的位置发生了变化，那么状态同步则会同步新的位置。又比如，一个角色的血量减少或者一个角色开始攻击，这些都属于状态的变化，都会进行同步。有的文章会认为位置的变化不算状态发生了改变，从移动状态变为停止状态这种才是状态改变，状态同步同步的是这种状态机发生的改变，我们认为这取决于对状态的拆分，对于一些依靠鼠标移动mmorpg而言，从一个点移动到另一个点是一个“元状态”,而对于一些FPS游戏而言，移动这个状态本身的参数就会发生变化，移动的方向、移动的速度，都会组成一个全新的状态，所以这些都符合状态同步的概念，当然，如果将状态帧同步单独作为一个同步方式来讲的话，后者其实更偏向于状态帧同步，这点后续会再讲到。</p><p>在一些MMORPG游戏中，当我们在网络环境不好的时候常常能看见有玩家突然从我们眼前瞬移的情况。这一般将是由于该游戏采用了状态同步的原因。<br>在状态同步中，服务器一般作为权威端处理所有关键逻辑，比如玩家攻击的伤害是多少，耗蓝了多少，受击者扣血多少，是否死亡等等，这些都由服务端计算并下发，客户端仅接受服务器数据并进行相应的表现逻辑。因为客户端不参与游戏核心逻辑的计算，所以状态同步在防外挂上有很好的表现。<br>但是这不意味着客户端不进行游戏核心逻辑的计算，为了让玩家在网络环境糟糕的时候也能够看到比较顺畅的游戏画面，在制作网络同步逻辑时，可以让玩家随意操控自己的角色，不受限于服务器端的延迟指令，在稍后进行服务器端校验时再对玩家进行矫正，最明显的例子就是传奇类游戏中的状态同步，在网络环境不太顺畅的情况下，我们仍然能操作自己的角色不停地移动，但过一段时间后，当客户端接收到服务器端发来的正确数据时，它就会对角色进行位置和状态的矫正。所以会出现在网络波动的情况下，角色瞬移的情况。这种技术称为预测回滚。<br>《守望先锋》、《CS：GO》等FPS游戏都使用的状态同步方案（更精确的说，《守望先锋》是使用的状态帧同步）。</p><h2 id="锁步帧同步"><a href="#锁步帧同步" class="headerlink" title="锁步帧同步"></a>锁步帧同步</h2><p>很多文章会把帧同步作为锁步帧同步来介绍。事实上</p><blockquote><p>帧同步不是单指某个具体算法，而是范指 “保证每帧（逻辑帧）输入一致” 的一系列算法，传统实现有帧锁定，乐观帧锁定，lockstep，bucket 同步等等，但凡满足“每帧输入一致”的方法皆可以归纳为帧同步类别，至于要不要回滚？服务端要不要跑一套完整逻辑？操作要不要是键盘鼠标？还是高阶命令？客户端要不要像视频播放器一样保证平滑缓存 1-2 帧？或者要不要保证平滑加一层显示对象的坐标插值？这些都是具体优化手段。</p></blockquote><p>锁步帧同步的逻辑不再由客户端本身的逻辑帧Update来决定，而是转由从网络收到帧数据包来驱动执行逻辑更新，这也是锁步帧同步最大的特点。所有的逻辑更新都会放在收到帧数据包时的操作中，包括人物角色的移动、攻击、释放技能等，客户端每收到一个服务器端发送过来的帧数据包，就会更新一帧或更新前面因延迟累积的帧数。<br><strong>采用锁步帧同步的游戏会有明确的逻辑帧的概念，锁步帧同步同步的是客户端操作</strong>，客户端会根据服务器发送的锁步帧同步数据包进行更新。在两个逻辑帧之间会有明显的间隔，为了使表现流畅，锁步帧同步游戏还会分出渲染帧的概念，来平滑两个逻辑帧之间的表现。<br>客户端会向服务器发送每个逻辑帧的操作，服务器将每个客户端的操作整合到一个帧数据包中，向所有客户端下发，客户端根据收到的帧数据包中每个玩家的操作还原出他们应该进行的逻辑表现。<br>客户端不断地收到从服务器端广播的帧数据，每帧都执行一次更新逻辑，执行到某一帧带有指令数据时就执行该帧内的所有指令，同时也更新逻辑。<br>比如，帧数据中的指令为某角色以每帧1米的速度向前移动，那么客户端就启动移动状态执行该指令，在接下来收到的帧数据中，客户端每执行一次逻辑更新就会执行一次每帧1米的逻辑，比如后面总共收到20帧的网络空数据帧，那么就执行20次每帧1米的行走逻辑，直到玩家再次操作停止移动指令，并把该指令发送给服务器端，服务器端再以帧数据的形式广播给所有玩家，任何玩家设备收到这个带有停止指令的帧数据时都会执行，以停止移动。</p><p>由于锁步帧同步同步的是操作，对于不同的终端，会出现浮点数计算的偏差问题，如何实现相同的操作指令在不同终端表现一致是一个复杂的问题，后续会详细介绍。<br>采用锁步帧同步的游戏如果没有定时保存全局的游戏快照的话，那么他的回放与断线重连系统会相当不友好。以王者荣耀（2025年）举例，王者在退出游戏断线重连（观战模式也类似）时，会进行一段长时间的加载界面等待，并且王者皮肤的特效变化会很明显的看出来进行了加速。这段时间就是后台在加速执行逻辑帧（可能从正常的1秒10帧变为了1秒50帧），通过加速来让断线的玩家终端追赶上正在进行游戏的玩家的逻辑帧。在王者荣耀的回放界面也同样可以发现，他只有快进按钮，而不能拖动进度条随意查看不同时间段的内容。同样的，在王者当前这套框架下，如果想要实现及时的死亡回放或者精彩集锦是不可能的，这是他底层采用的锁步帧同步技术所决定的（从这点上看王者荣耀似乎完全没有在服务器上跑逻辑？不然按一定时间间隔生成世界快照或者维护一个最新的世界快照状态的话也不至于会出现这种情况，不清楚他们对此是怎么考量的）。</p><h2 id="实时广播同步"><a href="#实时广播同步" class="headerlink" title="实时广播同步"></a>实时广播同步</h2><p>对于一些快速频繁变化的状态，有的游戏会将服务端对游戏逻辑的控制下放到客户端，<strong>由客户端完成游戏逻辑的计算，并通知服务端计算结果，服务端将此同步给其他需要同步的终端</strong>。<br>比如一部分游戏的移动和人物旋转，为了能更加逼真地同步模拟这种变化频率很高的人物移动和旋转动作，可以让客户端来决定其位置和旋转角度，这将牺牲一些数据的安全性来让画面显得更加真实流畅。<br>还有大部分可联机的单机游戏，一般存在一个主机和其他终端相连，其他终端计算好的数据会发送给主机进行广播同步。<br>实时广播同步方案的主要特点是，位置和旋转信息由客户端决定。客户端将自身的位置、旋转信息发送给服务器端，再由服务器端分发给其他玩家。在其他玩家收到位置、旋转信息后，根据收到的信息预测其当前的位置、速度、加速度、旋转速度和旋转加速度，并进行模拟和展示。当然，事实上，这些内容状态同步（状态帧同步）也可以实现，并且可以采用速度、加速度、角速度和角加速度来进行客户端本地预测，所以该方案不是完全不可代替。同时，实时广播同步会导致的数据安全性问题也不是无法避免，服务器可以获得客户端数据后进行校验，如果校验结果和真实逻辑差距过大，则会认为客户端数据不可信。但是，由于毕竟是客户端进行逻辑计算，这种服务端检验不能完全保证数据的安全性。</p><h2 id="快照同步"><a href="#快照同步" class="headerlink" title="快照同步"></a>快照同步</h2><p>快照同步方案也是客户端接受玩家输入然后上报给服务器，但是<strong>快照同步是在服务器进行核心逻辑计算，并且不停地生成整个世界状态的瞬时快照，按帧将世界快照下发给各个客户端，客户端根据这些快照来更新各自的世界状态。</strong><br>这种同步方式相当简单，但是在宽带消耗上较高。在优化上，可以使用增量来减少每帧下发一个全量快照的消耗，而这又退化成了一定时间段上的帧同步（帧同步就相当于在游戏开始时进行一次全量的世界快照同步，后续全采用增量的形式同步）；又或者进行差异化的同步，比如在某个客户端不可见的区域发生的变化就不向他同步了，没有发生变化的内容也不向客户端同步（这点优化又让快照同步偏向状态同步了）。<br>基于快照同步的回放、断线重连相当简单，应该服务器的每一帧快照数据包都可以重构整个游戏世界，所以客户端可以毫无难度的构建需要的时间点的游戏世界。<br>由于是服务器进行核心逻辑的计算，所以快照同步在安全性上也相当高。</p><h2 id="状态帧同步"><a href="#状态帧同步" class="headerlink" title="状态帧同步"></a>状态帧同步</h2><p><strong>状态帧同步会按固定的逻辑帧搜集变化的状态数据并进行网络同步</strong>。<br>和快照同步类似，状态帧同步会在服务端计算核心逻辑，并按帧向客户端发送的数据，不同点在于，状态帧同步是发送的<strong>发生变化的状态数据</strong>。简单的理解，状态帧同步事实上还是状态同步，因为他发送的是已经被服务器计算好的状态信息，但是发送的频率会更高。<br>举个详细的例子，对于玩家A，A在第$F_1$帧从位置$p_1$移动到了位置$P_2$，那么服务器在$F_1$帧会发送A的位置信息$P_2$，其他玩家收到该帧消息后更新A的逻辑位置。在第$F_1+1$帧，玩家A不移动，那么$F_1+1$的帧消息中就不会包括A的位置信息，其他玩家也不会更新A的逻辑位置。<br>由于状态帧同步会在服务端维护一个完整的游戏世界，所以对于断线重连和回放而言相当友好，在安全性上也比较高。</p><h2 id="网络同步方案的区别"><a href="#网络同步方案的区别" class="headerlink" title="网络同步方案的区别"></a>网络同步方案的区别</h2><p>以下表格不考虑服务器进行安全性检测、客户端进行本地预测之类的优化的情况，默认不会执行相关操作，仅讨论纯粹的该方案对相关内容是否必须。</p><div class="table-container"><table><thead><tr><th></th><th>服务端同步客户端内容</th><th>客户端向服务器上传内容</th><th>客户端是否通过逻辑帧驱动</th><th>游戏核心逻辑计算发生的地方</th></tr></thead><tbody><tr><td>状态同步</td><td>同步状态</td><td>客户端操作</td><td>非必须</td><td>服务端</td></tr><tr><td>锁步帧同步</td><td>同步操作</td><td>客户端操作</td><td>必须</td><td>客户端</td></tr><tr><td>实时广播同步</td><td>同步客户端要求广播的内容</td><td>客户端要求广播的内容</td><td>非必须</td><td>客户端</td></tr><tr><td>快照同步</td><td>同步快照</td><td>客户端操作</td><td>必须</td><td>服务端</td></tr><tr><td>状态帧同步</td><td>同步状态</td><td>客户端操作</td><td>必须</td><td>服务端</td></tr></tbody></table></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《Unity3D高级编程：主程手记》陆泽西</li><li><a href="https://blog.codingnow.com/2018/08/lockstep.html">lockstep 网络游戏同步方案</a></li><li><a href="https://skywind.me/blog/archives/2651">关于 “帧同步” 说法的历史由来</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
          <category> 网络同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 帧同步 </tag>
            
            <tag> 状态同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通讯（四）Protobuf详解</title>
      <link href="/posts/1876586415/"/>
      <url>/posts/1876586415/</url>
      
        <content type="html"><![CDATA[<h2 id="网络数据协议格式"><a href="#网络数据协议格式" class="headerlink" title="网络数据协议格式"></a>网络数据协议格式</h2><p>协议包格式有JSON、MsgPack、Protobuf格式以及自定义格式。在建设项目的网路层时，除了要选择传输协议TCP、UDP，以及应用层协议HTTP外，还需要选择在传输过程中的业务层协议格式。协议格式本质是数据的”包装方式”——就像快递打包时选择纸箱、泡沫箱或真空压缩袋。不同格式在”可读性”与”效率”上会有所权衡，比如书本人人可读但体积大；密码电报高效但需密码本。序列化/反序列化相当于”装箱/拆箱”过程，比如部分格式可以开箱即用，而部分是压缩袋打包的，开箱后则需将打包物体恢复原状。<br>除了上述格式外，还有比如YAML、XML甚至自定义二进制格式，这些只是数据的包装运输手段，同一份数据可以用不同的格式传输。所以协议格式的重点在于：</p><ul><li>序列化：数据被包装成该格式的过程</li><li>反序列化：从该格式的数据包中还原出原数据的过程</li><li>传输效率：序列化后的数据包大小。</li><li>可读性：序列化后的数据包能不能被人看出来原本的数据内容。</li></ul><p>这里不详细介绍JSON、MsgPack等格式，感兴趣的读者可以自行查找，这里仅介绍Protobuf。<br><span id="more"></span></p><h2 id="ProtoBuf-简介"><a href="#ProtoBuf-简介" class="headerlink" title="ProtoBuf 简介"></a>ProtoBuf 简介</h2><p><a href="https://protobuf.com.cn/overview/">ProtoBuf的官网</a>中这样介绍这个协议:<br>Protocol Buffers 是一种语言中立、平台中立、可扩展的序列化结构化数据的机制。它类似于 JSON，但更小、更快，并且生成原生语言绑定。你只需定义一次你想要的数据结构，然后就可以使用特殊生成的源代码轻松地以各种数据流和多种语言写入和读取你的结构化数据。<br>Protocol Buffers 提供了一种序列化格式，用于处理大小可达几兆字节的、带类型、结构化的数据包。这种格式适用于瞬时网络流量和长期数据存储。无需使现有数据失效或要求更新代码，即可使用新信息扩展 Protocol Buffers。<br>使用 Protocol Buffers 的一些优点包括</p><ul><li>紧凑的数据存储</li><li>快速解析</li><li>支持多种编程语言</li><li>通过自动生成的类实现优化的功能</li></ul><h2 id="语言语法"><a href="#语言语法" class="headerlink" title="语言语法"></a>语言语法</h2><p>proto3 比 proto2 支持更多语言但更简洁。去掉了一些复杂的语法和特性，更强调约定而弱化语法。这里仅介绍 proto3 的语法。<br><figure class="highlight proto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> Foo.Test;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Testmsg1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> testBool = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum </span><span class="title class_">EnumTest</span> &#123;</span><br><span class="line">  EnumTest1 = <span class="number">0</span>;</span><br><span class="line">  EnumTest2 = <span class="number">1</span>;</span><br><span class="line">  EnumTest3 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">TestPB</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">string</span> testString = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> testInt = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">sint32</span> testSInt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">repeated</span> Testmsg1 testMsgList = <span class="number">4</span>;</span><br><span class="line">    map&lt;<span class="type">string</span>, <span class="type">int32</span>&gt; testMap = <span class="number">5</span>;</span><br><span class="line">    EnumTest enumTest = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">oneof</span> testOneof </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">string</span> oneOfString = <span class="number">8</span>;</span><br><span class="line">        <span class="type">int32</span> oneOfInt = <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>在上述示例中，文件的第一行 <code>syntex</code> 指定使用的是 protobuf 语言规范的版本，例子中使用了 proto3 版本。<br>第二行使用 <code>import</code> 导入其他 <code>.proto</code> 文件中的定义，这里为了使用 <code>Any</code> 消息类型，必须导入 <code>google/protobuf/any.proto</code> 文件。<br>第三行使用 <code>package</code> 说明符（类似于命名空间），以防止类型之间发生名称冲突，在生成成对于语言的代码时，比如C#，<code>package</code> 也还会用作生成消息类的命名空间。<br>之后以 <code>message</code> 开头的 <code>Testmsg1</code> 表示在该 <code>package</code> 下创建一个名为 <code>Testmsg1</code> 的消息结构。<code>message</code> 是 Protobuf 中的核心概念，用于定义数据结构。在消息结构内部，<code>bool testBool = 1;</code> 用 <code>bool</code> 值指定了消息字段的类型，类型包括标量类型和自定义类型，详细的标量类型见<a href="#标量类型">标量类型</a>，<code>testBool</code> 指定了消息字段的命名，<code>1</code>是为该字段分配编号。</p><p>该消息类型生成的C#代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Foo.Test</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">global::ProtoBuf.ProtoContract()</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Testmsg1</span> : <span class="title">global</span>::<span class="title">ProtoBuf.IExtensible</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">global</span>::ProtoBuf.IExtension __pbn__extensionData;</span><br><span class="line">        <span class="keyword">global</span>::ProtoBuf.IExtension <span class="keyword">global</span>::ProtoBuf.IExtensible.GetExtensionObject(<span class="built_in">bool</span> createIfMissing)</span><br><span class="line">            =&gt; <span class="keyword">global</span>::ProtoBuf.Extensible.GetExtensionObject(<span class="keyword">ref</span> __pbn__extensionData, createIfMissing);</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(1)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> testBool &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以 <code>enum</code> 开头的消息类型定义了一个枚举，protobuf 官方规定，在 proto3 中，枚举定义中定义的第一个值必须为零，并且名称应为 <code>ENUM_TYPE_NAME_UNSPECIFIED</code> 或 <code>ENUM_TYPE_NAME_UNKNOWN</code>。还建议第一个默认值除了表示“此值未指定”之外不应该有其他语义含义。该消息类型生成的C#代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Foo.Test</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">global::ProtoBuf.ProtoContract()</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> EnumTest</span><br><span class="line">    &#123;</span><br><span class="line">        EnumTest1 = <span class="number">0</span>,</span><br><span class="line">        EnumTest2 = <span class="number">1</span>,</span><br><span class="line">        EnumTest3 = <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在最重要的 <code>TestPB</code> 消息结构中，编号 3、4、5 的字段分别使用了 <code>optional</code>、<code>repeated</code>、<code>map</code> 修饰符，这是指定字段基数的修饰符。在 proto3 中，消息字段可以具有以下的基数类型：</p><ul><li><code>optional</code> 单一字段，一个 <code>optional</code> 字段有两种可能的状态<ul><li>字段已设置，并包含一个被明确设置或从线格式解析的值。它将被序列化到线格式中。</li><li>字段未设置，将返回默认值。它不会被序列化到线格式中。</li></ul></li><li>隐式单一字段，为了最大限度地与 protobuf 版本和 proto2 兼容，<strong>推荐使用 <code>optional</code> 而非隐式字段</strong>。隐式字段没有明确的基数标签，并且行为如下：<ul><li>如果字段是消息类型，它的行为就像一个 <code>optional</code> 字段。</li><li>如果字段不是消息类型，它有两种状态<ul><li>字段设置为非默认值（非零），该值被明确设置或从线格式解析。它将被序列化到线格式中。</li><li>字段设置为默认值（零）。它不会被序列化到线格式中。</li></ul></li></ul></li><li><code>repeated</code>：此字段类型在格式良好的消息中可以重复零次或多次。重复值的顺序将得到保留。</li><li><code>map</code>：这是一种成对的键/值字段类型。<code>map</code> 字段只是特殊 <code>repeated</code> 字段的简写，相当于包含两个字段的 <code>repeated</code> 消息结构。<br>其中，编号4、6的字段使用了自定义的消息结构和枚举类型。<br>编号7的字段使用了 <code>Any</code> 类型，表明这是一个自定义的“泛化”的类型，<code>Any</code> 消息类型允许您将消息用作嵌入类型，而无需其 .proto 定义。一个 <code>Any</code> 包含一个任意序列化的消息作为 bytes，以及一个充当该消息类型全局唯一标识符并解析为该消息类型的 URL。要使用 Any 类型，需要导入 <code>google/protobuf/any.proto</code>。<br>编号8，9的字段被包括在被 <code>oneof</code> 修饰的消息体中，<code>oneof</code> 类似于C++中的 <code>Union</code> 联合体，<code>oneof</code> 中的所有字段共享内存，并且最多只能同时设置一个字段。<br><code>TestPB</code> 生成的C#代码如下：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Foo.Test</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">global::ProtoBuf.ProtoContract()</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">TestPB</span> : <span class="title">global</span>::<span class="title">ProtoBuf.IExtensible</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">global</span>::ProtoBuf.IExtension __pbn__extensionData;</span><br><span class="line">        <span class="keyword">global</span>::ProtoBuf.IExtension <span class="keyword">global</span>::ProtoBuf.IExtensible.GetExtensionObject(<span class="built_in">bool</span> createIfMissing)</span><br><span class="line">            =&gt; <span class="keyword">global</span>::ProtoBuf.Extensible.GetExtensionObject(<span class="keyword">ref</span> __pbn__extensionData, createIfMissing);</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(1)</span>]</span><br><span class="line">        [<span class="meta">global::System.ComponentModel.DefaultValue(<span class="string">&quot;&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> testString &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(2)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> testInt &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(3, DataFormat = global::ProtoBuf.DataFormat.ZigZag)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> testSInt</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> =&gt; __pbn__testSInt.GetValueOrDefault();</span><br><span class="line">            <span class="keyword">set</span> =&gt; __pbn__testSInt = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ShouldSerializetestSInt</span>()</span> =&gt; __pbn__testSInt != <span class="literal">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResettestSInt</span>()</span> =&gt; __pbn__testSInt = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span>? __pbn__testSInt;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(4, Name = @<span class="string">&quot;testMsgList&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">global</span>::System.Collections.Generic.List&lt;Testmsg1&gt; testMsgLists &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> <span class="keyword">global</span>::System.Collections.Generic.List&lt;Testmsg1&gt;();</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(5, Name = @<span class="string">&quot;testMap&quot;</span>)</span>]</span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMap</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">global</span>::System.Collections.Generic.Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; testMaps &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> <span class="keyword">global</span>::System.Collections.Generic.Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(6)</span>]</span><br><span class="line">        <span class="keyword">public</span> EnumTest enumTest &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(7, Name = @<span class="string">&quot;details&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">global</span>::System.Collections.Generic.List&lt;<span class="keyword">global</span>::Google.Protobuf.WellKnownTypes.Any&gt; Details &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> <span class="keyword">global</span>::System.Collections.Generic.List&lt;<span class="keyword">global</span>::Google.Protobuf.WellKnownTypes.Any&gt;();</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(8)</span>]</span><br><span class="line">        [<span class="meta">global::System.ComponentModel.DefaultValue(<span class="string">&quot;&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> oneOfString</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> =&gt; __pbn__testOneof.Is(<span class="number">8</span>) ? ((<span class="built_in">string</span>)__pbn__testOneof.Object) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">set</span> =&gt; __pbn__testOneof = <span class="keyword">new</span> <span class="keyword">global</span>::ProtoBuf.DiscriminatedUnion32Object(<span class="number">8</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ShouldSerializeoneOfString</span>()</span> =&gt; __pbn__testOneof.Is(<span class="number">8</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetoneOfString</span>()</span> =&gt; <span class="keyword">global</span>::ProtoBuf.DiscriminatedUnion32Object.Reset(<span class="keyword">ref</span> __pbn__testOneof, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">global</span>::ProtoBuf.DiscriminatedUnion32Object __pbn__testOneof;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">global::ProtoBuf.ProtoMember(9)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> oneOfInt</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> =&gt; __pbn__testOneof.Is(<span class="number">9</span>) ? __pbn__testOneof.Int32 : <span class="literal">default</span>;</span><br><span class="line">            <span class="keyword">set</span> =&gt; __pbn__testOneof = <span class="keyword">new</span> <span class="keyword">global</span>::ProtoBuf.DiscriminatedUnion32Object(<span class="number">9</span>, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ShouldSerializeoneOfInt</span>()</span> =&gt; __pbn__testOneof.Is(<span class="number">9</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetoneOfInt</span>()</span> =&gt; <span class="keyword">global</span>::ProtoBuf.DiscriminatedUnion32Object.Reset(<span class="keyword">ref</span> __pbn__testOneof, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><div class="table-container"><table><thead><tr><th>Proto类型</th><th>C#类型</th><th>备注</th></tr></thead><tbody><tr><td>double</td><td>double</td><td></td></tr><tr><td>float</td><td>float</td><td></td></tr><tr><td>int32</td><td>int</td><td>使用变长编码。对负数编码效率低下——如果您的字段可能包含负值，请改用 sint32。</td></tr><tr><td>int64</td><td>long</td><td>使用变长编码。对负数编码效率低下——如果您的字段可能包含负值，请改用 sint64。</td></tr><tr><td>uint32</td><td>uint</td><td>使用变长编码。</td></tr><tr><td>uint64</td><td>ulong</td><td>使用变长编码。</td></tr><tr><td>sint32</td><td>int</td><td>使用变长编码。有符号整数值。与常规 int32 相比，它们对负数编码更高效。</td></tr><tr><td>sint64</td><td>long</td><td>使用变长编码。有符号整数值。与常规 int64 相比，它们对负数编码更高效。</td></tr><tr><td>fixed32</td><td>uint</td><td>总是四个字节。如果值经常大于 $2^{28}$，比 uint32 更高效。</td></tr><tr><td>fixed64</td><td>ulong</td><td>总是八个字节。如果值经常大于 $2^{56}$，比 uint64 更高效。</td></tr><tr><td>sfixed32</td><td>int</td><td>总是四个字节。</td></tr><tr><td>sfixed64</td><td>long</td><td>总是八个字节。</td></tr><tr><td>bool</td><td>bool</td><td></td></tr><tr><td>string</td><td>string</td><td>字符串必须始终包含 UTF-8 编码或 7 位 ASCII 文本，且长度不能超过 $2^{32}$。</td></tr><tr><td>bytes</td><td>ByteString</td><td>可以包含任何不超过 $2^{32}$ 字节的任意字节序列。</td></tr></tbody></table></div><p>其他详情见<a href="https://protobuf.com.cn/programming-guides/proto3/#scalar">官网介绍</a></p><h2 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h2><p>首先需要明确 Proto 中的线格式（Wire Format）概念，​​线格式是实际在网络传输或存储中使用的二进制编码格式，其设计基于 ​​TLV（Tag-Length-Value）结构​​，但会根据数据类型动态简化。</p><h3 id="可变宽度整数（varints）"><a href="#可变宽度整数（varints）" class="headerlink" title="可变宽度整数（varints）"></a>可变宽度整数（varints）</h3><p>可变宽度整数，或称 varints，是线格式的核心。它们允许使用一到十个字节编码无符号 64 位整数，其中小值使用较少的字节。<br>varint 中的每个字节都有一个延续位，指示其后面的字节是否是 varint 的一部分。这是字节的最高有效位 (MSB)（有时也称为符号位）。较低的 7 位是有效载荷；通过将其组成字节的 7 位有效载荷拼接在一起构建出结果整数。如下例子：<br>数字 1 编码为 <code>01</code> – 这可以被七位表示，所以 MSB 未设置，为0。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0001</span><br><span class="line">^ msb</span><br></pre></td></tr></table></figure><br>数字 150，编码为 <code>9601</code> 翻译为二进制为 <code>10010110</code>，会被 varints 编码为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10010110 00000001</span><br><span class="line">^ msb    ^ msb</span><br></pre></td></tr></table></figure><br>首先，第一个字节后7位被设置完，还无法表示完这个数字，所以第一个字节的第8位的 MSB 被设置为 1，表示后一个字节也是该 varint 的一部分，这些 7 位有效载荷是小端序的。转换为大端序，连接起来，并解释为无符号 64 位整数，及 <code>0000001  0010110</code> 等于二进制的 150 。</p><h3 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h3><p>protocol buffer 消息是一系列键值对。消息的二进制版本仅使用字段编号作为键 – 每个字段的名称和声明类型只能在解码端通过引用消息类型的定义（即 .proto 文件）来确定。<br>消息编码时，每个键值对都会转换为一个记录，包含<strong>字段编号、线类型和有效载荷</strong>。线类型告诉解析器其后面的有效载荷有多大。这使得旧的解析器可以跳过它们不理解的新字段。这种方案被称为 Tag-Length-Value，或 TLV。<br>在proto中线类型有6种：<code>VARINT</code>、<code>I64</code>、<code>LEN</code>、<code>SGROUP</code>、<code>EGROUP</code> 和 <code>I32</code></p><div class="table-container"><table><thead><tr><th>ID</th><th>名称</th><th>用于</th></tr></thead><tbody><tr><td>0</td><td>VARINT</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td>1</td><td>I64</td><td>fixed64, sfixed64, double</td></tr><tr><td>2</td><td>LEN</td><td>string, bytes, 嵌入式消息, 紧凑重复字段</td></tr><tr><td>3</td><td>SGROUP</td><td>组开始 (已弃用)</td></tr><tr><td>4</td><td>EGROUP</td><td>组结束 (已弃用)</td></tr><tr><td>5</td><td>I32</td><td>fixed32, sfixed32, float</td></tr></tbody></table></div><p>这里的 <code>Tag</code> 会被编码为一个 <code>varints</code> ，解码后的数据低3位表示线类型、其余位表示字段编号，写成公式就是<code>(field_number &lt;&lt; 3) | wire_type</code>。比如 <code>0000 1000</code> 数据，MSB为0，可以直接去掉。后三位即线类型为0，其余整数即字段编号为1。那么，该字节表示的数据是字段编号为1，类型为 <code>VARINT</code> 的tag。由此我们知道应该用 <code>VARINT</code> 来解码有效载荷的数据，假设和<a href="#可变宽度整数（varints）">可变宽度整数（varints）</a>中的例子一致，那么解码出来的有效载荷数据为150。我们就知道了消息体里编号为1的字段，数据为150。</p><h3 id="ZigZag编码"><a href="#ZigZag编码" class="headerlink" title="ZigZag编码"></a>ZigZag编码</h3><p>考虑 <code>varints</code> 编码的负数，例如-2，在可编码64位的 <code>varints</code> 格式下，将会转换成2的补码。</p><blockquote><ul><li>原码：原码是最直观的表示方法，它直接用二进制数表示一个数，包括正负号。在原码中，最高位（最左边的位）是符号位，0 表示正数，1 表示负数。其余位表示数值本身。例如，十进制数 +5 的原码表示为0000 0101，而 -5 的原码表示为 1000 0101。</li><li>反码：反码主要用于表示负数。对于正数，其反码与其原码相同。对于负数，其反码是将原码除符号位外的所有位取反（0 变 1，1 变 0）。例如，十进制数-5的反码表示为1111 1010。</li><li>补码：补码是计算机中最常用的表示方法，用于进行二进制加法运算。对于正数，其补码与其原码相同。对于负数，其补码是其反码加 1。补码的一个重要特性是，任何数的补码加上该数本身，结果总是 0。例如，十进制数 -5 的补码表示为 1111 1011。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- -2的补码编码 --&gt;</span><br><span class="line">11111111 11111111 11111111 11111111</span><br><span class="line">11111111 11111111 11111111 11111110</span><br><span class="line">&lt;!-- varints编码-2补码形式 --&gt;</span><br><span class="line">11111110 11111111 11111111 11111111 11111111</span><br><span class="line">11111111 11111111 11111111 11111111 00000001</span><br></pre></td></tr></table></figure><p>如上所示，<code>varints</code> 由于最高有效位 (MSB)的存在，会多使用2个字节来表示-2这个数。<br>为了解决这个问题，proto 使用 <code>ZigZag</code> 编码而不是补码来编码负整数。<code>ZigZag</code>采用这样的方式来编码数据：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ZagZig</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x 是非负数数：</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span> * x - <span class="number">1</span></span><br><span class="line"><span class="comment"># ZagZig(-1) = 1</span></span><br><span class="line"><span class="comment"># ZagZig(1) = 2</span></span><br><span class="line"><span class="comment"># ZagZig(-2) = 3</span></span><br><span class="line"><span class="comment"># ZagZig(2) = 4</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><br><code>ZigZag</code>编码让数据按绝对值从小到大均匀的分布在非负整数上，且具有偶数是正整数，奇数是负整数的特点。直接的说，对于32位sint值n，按 <code>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code> 方式编码。</p><h3 id="长度分隔记录"><a href="#长度分隔记录" class="headerlink" title="长度分隔记录"></a>长度分隔记录</h3><p>长度前缀是线格式中的另一个主要概念。<code>LEN</code> 线类型具有动态长度，由标签后的 varint 指定，其后是通常的有效载荷。<br>考虑 <code>LEN</code> 线类型的字符串：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message Test2 &#123;</span><br><span class="line">  string b = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>假设我们给一个 <code>Test2</code> 类型消息赋值为 “testing”，那么编码该记录会得到 <code>12 07 74 65 73 74 69 6e 67</code>。<br>在编码后的数据中，标签 <code>12</code> 二进制为 <code>0 00010 010</code> 他的 <code>MSB</code> 为0，后三位即线类型为2，其余位即字段编号为2，和我们定义的一致。由于这是<code>LEN</code> 线类型，他之后是 <code>int32 varint</code> 格式的有效载荷长度。<code>07</code> 二进制为 <code>0000 0111</code>，其 <code>MSB</code> 为0，所以表示数据长度为7，对应于“testing”7个字符。</p>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP/TCP </tag>
            
            <tag> 网络 </tag>
            
            <tag> Protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通讯（三）KCP协议详解</title>
      <link href="/posts/2662722858/"/>
      <url>/posts/2662722858/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://github.com/skywind3000/kcp">KCP - A Fast and Reliable ARQ Protocol</a><br>KCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。<br><span id="more"></span><br><a href="https://github.com/libinzhangyuan/reliable_udp_bench_mark/blob/master/bench_mark.md">reliable_udp_bench_mark</a> 比较了多个基于UDP的可靠传输框架，并给出了下面的结论：<br>并给出结论如下：</p><ul><li>The kcp is the first choice for realtime pvp game.</li><li>The lag is less than 1 second when network lag happen. 3 times better than enet when lag happen.</li><li>The enet is a good choice if your game allow 2 second lag.</li><li>UDT is a bad idea. It always sink into badly situation of more than serval seconds lag. And the recovery is not expected.</li></ul><p>大型多人游戏服务端引擎 SpatialOS 在集成 KCP 协议后做了同 TCP/RakNet 的评测：<br><img src="https://github.com/skywind3000/kcp/raw/master/images/spatialos-50.png" alt=""><br>同时，《王者荣耀》、《原神》等用户规模庞大的项目也都有使用KCP协议。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>在该仓库的ReadMe中介绍的技术特性包括：</p><ul><li>RTO翻倍vs不翻倍：<br>TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。</li><li>选择性重传 vs 全部重传：<br>TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。</li><li>快速重传：<br>发送端发送了1，2，3，4，5几个包，然后收到远端的ACK: 1，3，4，5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。</li><li>延迟ACK vs 非延迟ACK：<br>TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。</li><li>UNA vs ACK+UNA：<br>ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。</li><li>非退让流控：<br>KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。</li></ul><p>事实上，通过前面<a href="/posts/3544708607/" title="游戏中的网络通信（二）TCP协议详解">关于TCP的博客</a>的介绍我们也发现了，TCP同样可以实现选择重传、快重传。而且在快重传规则下，额外的选择重传功能意义不大。从源码看，KCP也确实没有额外实现一套选择重传的功能，README里应该是把快重传功能作为一个选择重传的实现写上去了。<br>通过对比源码来看，KCP主要实现了下面的功能：</p><ul><li>让TCP的$Karn$算法改进部分，超时计算从TCP的RTOx2变为RTOx1.5。</li><li>TCP的快重传指发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为该报文段设置的重传计时器到期。在KCP中将重传需要收到的重复确认次数变为可配置的，一般被配置成2次。</li><li>KCP将丢包退让和慢启动变为可配置，出现丢包后不会进行门限值ssthresh的减半和慢启动。</li><li>这一点是KCP最核心的改动，KCP协议首部中，同时包含了ACK（该编号包已收到）和UNA（此编号前所有包已收到，相当于发送窗口的左指针）信息。这使得快重传和选择重传的效率变得更高。</li></ul><h2 id="KCP首部格式"><a href="#KCP首部格式" class="headerlink" title="KCP首部格式"></a>KCP首部格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0               4   5   6       8 (BYTE)</span><br><span class="line">+---------------+---+---+-------+</span><br><span class="line">|     conv      |cmd|frg|  wnd  |</span><br><span class="line">+---------------+---+---+-------+   8</span><br><span class="line">|     ts        |     sn        |</span><br><span class="line">+---------------+---------------+  16</span><br><span class="line">|     una       |     len       |</span><br><span class="line">+---------------+---------------+  24</span><br><span class="line">|                               |</span><br><span class="line">|        DATA (optional)        |</span><br><span class="line">|                               |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><ul><li>conv 4 字节: 连接标识符，用于识别一个特定的会话。</li><li>cmd 1 字节: Command。</li><li>frg 1 字节: 分片数量. 表示随后还有多少个报文属于同一个包。</li><li>wnd 2 字节: 发送方剩余接收窗口的大小。</li><li>ts 4 字节: 时间戳。</li><li>sn 4 字节: 报文编号。</li><li>una 4 字节: 发送方的接收缓冲区中最小还未收到的报文段的编号. 也就是说, 编号比它小的报文段都已全部接收。</li><li>len 4 字节: 数据段长度。</li><li>data: 数据段. 只有数据报文会有这个字段。</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>KCP 的整个发送，接收与重传的流程大体如下:</p><ul><li>调用 ikcp_send 发送数据，创建报文段实例，加入 snd_queue 中。</li><li>ikcp_update 会在合适的时刻调用 ikcp_flush。</li><li>ikcp_flush 会做:<ul><li>发送 ACK 列表中所有的 ACK。</li><li>检查是否需要发送窗口探测和通知报文，如果需要就发送相应的报文。</li><li>根据发送窗口大小，将适量的报文段从 snd_queue 移入到 snd_buf 中。</li><li>将 snd_buf 中满足条件的报文段都发送出去. 这里的条件有。<ul><li>新加入 snd_buf 中，从未发送过的报文直接发送出去。</li><li>发送过的，但是在 RTO 内未收到 ACK 的报文，需要重传。</li><li>发送过的，但是 ACK 失序若干次的报文，需要执行快速重传。</li></ul></li><li>根据丢包情况计算 ssthresh 和 cwnd。</li></ul></li><li>这样，刚才调用 ikcp_send 传入的数据就在 ikcp_flush 中被发送出去了。</li><li>报文到达对端。</li><li>ikcp_input 会被调用，解析收到的数据:<ul><li>所有的报文都有 una 字段，根据 una 将相应的报文标记为已送达。</li><li>如果是 ACK 报文，就将相应的报文标记为已送达。</li><li>如果是数据报文，就将它放入 rcv_buf，然后将 rcv_buf 中顺序正确的报文移入 rcv_queue; 接着将相关信息插入 ACK 列表，在稍后的 ikcp_flush 调用中会发送相应的 ACK。</li><li>如果是窗口探测报文，就标记 “需要发送窗口通知”. 在稍后的 ikcp_flush 调用中会发送窗口通知报文。</li><li>包括窗口通知报文在内的所有报文都有 wnd 字段，据此更新 rmt_wnd。</li><li>根据 ACK 失序情况决定快速重传。</li><li>计算 cwnd。</li></ul></li><li>调用 ikcp_recv 接收数据，从 rcv_queue 中读取数据。<br>之后 ACK 会返回给发送方，发送方在 ikcp_input 中解析到 ACK，将对应的报文标记为已送达，这就完成了一次发送. 如果发生了丢包，发送方最终收不到 ACK. 这会导致重传。</li></ul><p>下面举个简单的例子：<br><img src="/posts/2662722858/kcp_5.svg" class="" title="kcp流程"></p><ol><li>t1 时刻发送方发送 1 号报文，1 号报文放入发送缓冲区中，snd_una 指向 1，snd_nxt 指向 2。</li><li>t2 至 t3 时刻发送方依次发送 2 至 3 号报文，snd_nxt 依次后移。</li><li>1 号报文丢包。</li><li>t4，t5 时刻接收方收到 3 号和 2 号报文，放入 rcv_buf 中; 随后回复 3 号和 2 号 ACK。此时由于 1 号报文缺失，rcv_nxt 始终指向 1。</li><li>3 号 ACK 丢包。</li><li>t7 时刻发送方收到 2 号 ACK，将 2 号报文标记为已送达。此时由于 3 号 ACK 丢包，3 号报文未标记为已送达。由于 1 号报文未确认送达，snd_una 亦指向 1。</li><li>t8 时刻 1 号报文超时，重传。</li><li>t9 时刻接收方收到 1 号报文，放入 rcv_buf 中; 这时 1，2，3 号报文顺序正确，rcv_nxt 右移到 4 号位置。接收方回复 1 号 ACK，同时带上 una = 4。</li><li>t10 时刻发送方收到 1 号 ACK，将 1 号报文标记为已送达。同时 una 表明 1，2，3 号报文均已送达，因此也将 3 号报文标记为已送达。snd_una 移动到 4。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">//=====================================================================</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// test.cpp - kcp 测试用例</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 说明：</span></span><br><span class="line"><span class="comment">// gcc test.cpp -o test -lstdc++</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//=====================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ikcp.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟网络</span></span><br><span class="line">LatencySimulator *vnet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟网络：模拟发送一个 udp包</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_output</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> len, ikcpcb *kcp, <span class="type">void</span> *user)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span> <span class="type">int</span> id; <span class="type">void</span> *ptr; &#125; parameter;</span><br><span class="line">parameter.ptr = user;</span><br><span class="line">vnet-&gt;send(parameter.id, buf, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 创建模拟网络：丢包率10%，Rtt 60ms~125ms</span></span><br><span class="line">vnet = new LatencySimulator(<span class="number">10</span>, <span class="number">60</span>, <span class="number">125</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个端点的 kcp对象，第一个参数 conv是会话编号，同一个会话需要相同</span></span><br><span class="line"><span class="comment">// 最后一个是 user参数，用来传递标识</span></span><br><span class="line">ikcpcb *kcp1 = ikcp_create(<span class="number">0x11223344</span>, (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">ikcpcb *kcp2 = ikcp_create(<span class="number">0x11223344</span>, (<span class="type">void</span>*)<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置kcp的下层输出，这里为 udp_output，模拟udp网络输出函数</span></span><br><span class="line">kcp1-&gt;output = udp_output;</span><br><span class="line">kcp2-&gt;output = udp_output;</span><br><span class="line"></span><br><span class="line">IUINT32 current = iclock();</span><br><span class="line">IUINT32 slap = current + <span class="number">20</span>;</span><br><span class="line">IUINT32 index = <span class="number">0</span>;</span><br><span class="line">IUINT32 next = <span class="number">0</span>;</span><br><span class="line">IINT64 sumrtt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxrtt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置窗口大小：平均延迟200ms，每20ms发送一个包，</span></span><br><span class="line"><span class="comment">// 而考虑到丢包重发，设置最大收发窗口为128</span></span><br><span class="line">ikcp_wndsize(kcp1, <span class="number">128</span>, <span class="number">128</span>);</span><br><span class="line">ikcp_wndsize(kcp2, <span class="number">128</span>, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断测试用例的模式</span></span><br><span class="line"><span class="keyword">if</span> (mode == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 默认模式</span></span><br><span class="line">ikcp_nodelay(kcp1, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ikcp_nodelay(kcp2, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 普通模式，关闭流控等</span></span><br><span class="line">ikcp_nodelay(kcp1, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">ikcp_nodelay(kcp2, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 启动快速模式</span></span><br><span class="line"><span class="comment">// 第二个参数 nodelay-启用以后若干常规加速将启动</span></span><br><span class="line"><span class="comment">// 第三个参数 interval为内部处理时钟，默认设置为 10ms</span></span><br><span class="line"><span class="comment">// 第四个参数 resend为快速重传指标，设置为2</span></span><br><span class="line"><span class="comment">// 第五个参数 为是否禁用常规流控，这里禁止</span></span><br><span class="line">ikcp_nodelay(kcp1, <span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">ikcp_nodelay(kcp2, <span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">kcp1-&gt;rx_minrto = <span class="number">10</span>;</span><br><span class="line">kcp1-&gt;fastresend = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> hr;</span><br><span class="line"></span><br><span class="line">IUINT32 ts1 = iclock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">isleep(<span class="number">1</span>);</span><br><span class="line">current = iclock();</span><br><span class="line">ikcp_update(kcp1, iclock());</span><br><span class="line">ikcp_update(kcp2, iclock());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔 20ms，kcp1发送数据</span></span><br><span class="line"><span class="keyword">for</span> (; current &gt;= slap; slap += <span class="number">20</span>) &#123;</span><br><span class="line">((IUINT32*)buffer)[<span class="number">0</span>] = index++;</span><br><span class="line">((IUINT32*)buffer)[<span class="number">1</span>] = current;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送上层协议包</span></span><br><span class="line">ikcp_send(kcp1, buffer, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理虚拟网络：检测是否有udp包从p1-&gt;p2</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">hr = vnet-&gt;recv(<span class="number">1</span>, buffer, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">if</span> (hr &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 如果 p2收到udp，则作为下层协议输入到kcp2</span></span><br><span class="line">ikcp_input(kcp2, buffer, hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理虚拟网络：检测是否有udp包从p2-&gt;p1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">hr = vnet-&gt;recv(<span class="number">0</span>, buffer, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">if</span> (hr &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 如果 p1收到udp，则作为下层协议输入到kcp1</span></span><br><span class="line">ikcp_input(kcp1, buffer, hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kcp2接收到任何包都返回回去</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">hr = ikcp_recv(kcp2, buffer, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 没有收到包就退出</span></span><br><span class="line"><span class="keyword">if</span> (hr &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 如果收到包就回射</span></span><br><span class="line">ikcp_send(kcp2, buffer, hr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kcp1收到kcp2的回射数据</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">hr = ikcp_recv(kcp1, buffer, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 没有收到包就退出</span></span><br><span class="line"><span class="keyword">if</span> (hr &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">IUINT32 sn = *(IUINT32*)(buffer + <span class="number">0</span>);</span><br><span class="line">IUINT32 ts = *(IUINT32*)(buffer + <span class="number">4</span>);</span><br><span class="line">IUINT32 rtt = current - ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sn != next) &#123;</span><br><span class="line"><span class="comment">// 如果收到的包不连续</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ERROR sn %d&lt;-&gt;%d\n&quot;</span>, (<span class="type">int</span>)count, (<span class="type">int</span>)next);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next++;</span><br><span class="line">sumrtt += rtt;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (rtt &gt; (IUINT32)maxrtt) maxrtt = rtt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[RECV] mode=%d sn=%d rtt=%d\n&quot;</span>, mode, (<span class="type">int</span>)sn, (<span class="type">int</span>)rtt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ts1 = iclock() - ts1;</span><br><span class="line"></span><br><span class="line">ikcp_release(kcp1);</span><br><span class="line">ikcp_release(kcp2);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *names[<span class="number">3</span>] = &#123; <span class="string">&quot;default&quot;</span>, <span class="string">&quot;normal&quot;</span>, <span class="string">&quot;fast&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s mode result (%dms):\n&quot;</span>, names[mode], (<span class="type">int</span>)ts1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;avgrtt=%d maxrtt=%d tx=%d\n&quot;</span>, (<span class="type">int</span>)(sumrtt / count), (<span class="type">int</span>)maxrtt, (<span class="type">int</span>)vnet-&gt;tx1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;press enter to next ...\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> ch; <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">test(<span class="number">0</span>);<span class="comment">// 默认模式，类似 TCP：正常模式，无快速重传，常规流控</span></span><br><span class="line">test(<span class="number">1</span>);<span class="comment">// 普通模式，关闭流控等</span></span><br><span class="line">test(<span class="number">2</span>);<span class="comment">// 快速模式，所有开关都打开，且关闭流控</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">default mode result (20917ms):</span></span><br><span class="line"><span class="comment">avgrtt=740 maxrtt=1507</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">normal mode result (20131ms):</span></span><br><span class="line"><span class="comment">avgrtt=156 maxrtt=571</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">fast mode result (20207ms):</span></span><br><span class="line"><span class="comment">avgrtt=138 maxrtt=392</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://luyuhuang.tech/2020/12/09/kcp.html">详解 KCP 协议的原理和实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/10153049382">KCP 源码分析与原理总结</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP/TCP </tag>
            
            <tag> 网络 </tag>
            
            <tag> KCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通信（二）TCP协议详解</title>
      <link href="/posts/3544708607/"/>
      <url>/posts/3544708607/</url>
      
        <content type="html"><![CDATA[<p>介绍了TCP协议的核心机制，主要包括四个方面：TCP可靠传输、TCP流量控制、TCP拥塞控制、TCP连接管理。<br><span id="more"></span></p><h2 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>TCP的滑动窗口是以字节为单位的，包括发送窗口和接受窗口两种形式。<br><img src="/posts/3544708607/%E6%8E%A5%E5%8F%97%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.png" class="" title="接受窗口和发送窗口"><br>发送窗口表示：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。如图所示，要描述一个发送窗口的状态需要三个指针：P1，P2和P3。<br>小于P1的是已发送并已收到确认的部分，而大于P3的是不允许发送的部分。<br>P3 - P1 = A的发送窗口（又称为通知窗口）<br>P2 - P1 = 已发送但尚未收到确认的字节数<br>P3 - P2 = 允许发送但尚未发送的字节数（又称为可用窗口或有效窗口）</p><p>接收窗口相比比较简单，只有前沿和后沿，后沿表示已发送确认并且交付上层主机的数据，前沿表示不允许接受的最小序号，前后沿之间就是接受窗口。如图所示，B还收到了序号为32和33的数据，但这些都没有按序到达，只能先暂存在接收窗口中。<br>当A在发送完窗口内的数据后，发送窗口内的序号都属于已发送但未被确认，在经过一段时间后（由超时计时器控制）A会重传已发送但未收到确认的数据，重新设置超时计时器，直到收到B的确认为止。如果A收到确认号落在发送窗口内，那么A就可以使发送窗口继续向前滑动，并发送新的数据。</p><h3 id="缓存和窗口的关系"><a href="#缓存和窗口的关系" class="headerlink" title="缓存和窗口的关系"></a>缓存和窗口的关系</h3><p>首先需要明确，缓存空间和序号空间都是有限的，并且都是循环使用的。最好是把它们画成圆环状的。实际上缓存或窗口中的字节数是非常之大的，因此无法在图中把一个个字节的位置标注清楚，图中假设缓存与窗口都较小。<br><img src="/posts/3544708607/TCP%E7%9A%84%E7%BC%93%E5%AD%98%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB.png" class="" title="TCP的缓存和窗口的关系"><br>发送缓存用来暂时存放：</p><ol><li>发送应用程序传送给发送方TCP准备发送的数据</li><li>TCP已发送出但尚未收到确认的数据</li></ol><p>接收缓存用来暂时存放：</p><ol><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>未按序到达的数据</li></ol><h4 id="格外需要注意的"><a href="#格外需要注意的" class="headerlink" title="格外需要注意的"></a>格外需要注意的</h4><ol><li>虽然A的发送窗口是根据B的接收窗口设置的，但在同一时刻，A的发送窗口并不总是和B的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后（这个时间还是不确定的）​。另外，发送方A还可能根据网络当时的拥塞情况适当减小自己的发送窗口数值。</li><li>对于不按序到达的数据应如何处理，TCP标准并无明确规定。如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利（因为发送方会重复传送较多的数据）​。因此TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP要求接收方必须有累积确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。但请注意两点，一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就要发送一个确认[RFC 1122]​。二是捎带确认实际上并不经常发生，因为大多数应用程序不同时在两个方向上发送数据。</li></ol><h3 id="超时重传时间的计算"><a href="#超时重传时间的计算" class="headerlink" title="超时重传时间的计算"></a>超时重传时间的计算</h3><p>对于$RTO (RetransmissionTime-Out)$的计算，TCP采用了一种自适应算法。<br>它首先记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间$RTT$。TCP保留了$RTT$的一个加权平均往返时间$RTT_{S}$（这又称为平滑的往返时间，S表示Smoothed）。如下所示，其中，RFC 2988推荐的α值为1/8。</p><script type="math/tex; mode=display">新的RTT_{S} = (1-\alpha) \times(旧的RTT_{s})+\alpha\times(新的RTT样本)</script><p>而$RTO$应略大于上面得出的加权平均往返时间$RTT_{S}$。</p><script type="math/tex; mode=display">RTO=RTT_{S}+4\times RTT_{D}</script><p>而$RTT_{D}$是$RTT$的偏差的加权平均值，它与$RTT_S$和新的$RTT$样本之差有关。</p><script type="math/tex; mode=display">新的RTT_D=(1-\beta)\times (旧的RTT_{D})+\beta\times \left| RTT_S-新的RTT样本 \right|</script><p>其中$\beta$的推荐值是1/4。</p><p>现在需要解决这样一个问题，发送出一个报文段。设定的重传时间到了，还没有收到确认。于是重传报文段。经过了一段时间后，收到了确认报文段。如何判定此确认报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？<br>这里采用改进的$Karn$算法：在计算加权平均$RTT_S$时，只要报文段重传了，就不采用其往返时间样本。报文段每重传一次，就把超时重传时间$RTO$增大一些。典型的做法是取新的重传时间为2倍的旧的重传时间。</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>流量控制是让发送方的发送速率不要太快，要让接收方来得及接收。流量控制是接收方对发送方的控制，在TCP中通过首部的窗口字段进行控制。<br>比如，如果接受方在第一次协商时发送窗口值为500，表示接收方的接受窗口有500大小，发送方的发送窗口需要和接受方窗口大小同步；后续接收方修改窗口值为200，表示接收方来不及接受处理这么多数据或者其他原因，所以收窄接受窗口到200；后续接受方修改窗口值为0，表示接收方不允许发送方再发数据了，直到接收方重新发送消息更新窗口值。<br>这里有一种情况，如果窗口值被更新为0后，接收方发送的更新窗口值的新消息在发送过程中丢失了，那么会出现发送方等待窗口值更新的报文，并且接受方等待发送方发送报文的死锁局面。<br>为了解决这个问题，TCP为每一个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据）​，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</p><h3 id="TCP报文发送时机"><a href="#TCP报文发送时机" class="headerlink" title="TCP报文发送时机"></a>TCP报文发送时机</h3><p>考虑这样一种情况，用户每次只发一个字符，并且要求接收方回传一个字符，线路上就需传送总长度为162字节共4个报文段（TCP首部+IP首部 共40字节，假定接受确认数据报没有数据发送）。当线路带宽并不富裕时，这种传送方法的效率的确不高。因此应适当推迟发回确认报文，并尽量使用捎带确认的方法。<br>在TCP的实现中广泛使用Nagle算法。算法如下：<br>若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。这样做，就可以有效地提高网络的吞吐量。</p><p>再考虑这样一种情况（<strong>糊涂窗口综合症(silly window syndrome)[RFC 813]​</strong>），TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1个字节（这样就使接收缓存空间仅腾出1个字节）​，然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报是40字节长）​。接着，发送方又发来1个字节的数据（请注意，发送方发送的IP数据报是41字节长）​。接收方发回确认，仍然将窗口设置为1个字节。这样进行下去，使网络的效率很低。<br>可以让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</p><p>上述两种方法可配合使用。使得在发送方不发送很小的报文段的同时，接收方也不要在缓存刚刚有了一点小的空间就急忙把这个很小的窗口大小信息通知给发送方。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>在计算机网络中的链路容量（即带宽）​、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。类似于城市道路因车辆需求超过道路通行、信号处理或路口容纳能力而发生的堵车。想象玩天际线游戏修路的时候，常常发现扩容了一段路确并不会改善堵车的情况，网络拥塞也是一个非常复杂的问题，由很多因素引起，简单地扩大缓存的存储空间同样会造成网络资源的严重浪费，因而解决不了网络拥塞的问题。<br>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。而流量控制往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端）​。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。这两者是不同的，不能混为一谈。<br>因特网建议标准RFC 2581定义了进行拥塞控制的四种算法，即慢开始(slow-start)、拥塞避免(congestion avoidance)、快重传(fast retransmit)和快恢复(fast recovery)。</p><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h3><p>发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。事实上，由于还有流量控制的存在，发送方的窗口上限是接收方窗口（cwnd）和拥塞窗口（cwnd）的最小值。<br>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>慢开始算法的思路是这样的。当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。经验证明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。<br>使用慢开始算法后，每经过一个传输轮次，拥塞窗口cwnd就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过使用“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。<br>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量​。慢开始门限ssthresh的用法如下：</p><ol><li>当cwnd &lt; ssthresh时，使用上述的慢开始算法。</li><li>当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。<br>拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样，拥塞窗口cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</li></ol><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认）​，就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p><img src="/posts/3544708607/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B.png" class="" title="慢开始和拥塞避免算法的实现举例"><p>在TCP拥塞控制的文献中经常可看见“乘法减小”(Multiplicative Decrease)和“加法增大”(Additive Increase)这样的提法。​“乘法减小”是指不论在慢开始阶段还是拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞）​，就把慢开始门限值ssthresh减半，即设置为当前的拥塞窗口的一半（与此同时，执行慢开始算法）​。当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入到网络中的分组数。而“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。上面两种算法合起来常称为AIMD算法（加法增大乘法减小）​。</p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等待自己发送数据时才进行捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为该报文段设置的重传计时器到期。<br>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><ol><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重的拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认）​，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1）​，而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（​“加法增大”​）​，使拥塞窗口缓慢地线性增大。</li></ol><img src="/posts/3544708607/%E4%BB%8E%E8%BF%9E%E7%BB%AD%E6%94%B6%E5%88%B0%E4%B8%89%E4%B8%AA%E9%87%8D%E5%A4%8D%E7%9A%84%E7%A1%AE%E8%AE%A4%E8%BD%AC%E5%85%A5%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" class="" title="从连续收到三个重复的确认转入拥塞避免"><h3 id="随机早期检测RED"><a href="#随机早期检测RED" class="headerlink" title="随机早期检测RED"></a>随机早期检测RED</h3><p>这个算法主要是运用在网络层路由器上的，这个不做详细讨论，只做简要介绍。<br>路由器缓存队列中如果已满，以后再到达的所有分组将都被丢弃。这就使发送方出现超时重传，使TCP进入拥塞控制的慢开始状态，结果使TCP连接的发送方突然把数据的发送速率降低到很小的数值。在网络中通常有很多的TCP连接（它们有不同的源点和终点）​，这些连接中的报文段通常是复用在网络层的IP数据报中传送。在这种情况下，若发生了路由器中的尾部丢弃，就可能会同时影响到很多条TCP连接，结果就使这许多的TCP连接在同一时间突然都进入到慢开始状态。<br>随机早期检测 RED 就是为了解决上述情况。RED把路由器的分组到达队列划分为三个区域，即正常排队、以概率$p$丢弃和必须丢弃的区域。<br>RED不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，而是在检测到网络拥塞的早期征兆时（即路由器的平均队列长度超过一定的门限值时）​，就先以概率$p$随机丢弃个别的分组，让拥塞控制只在个别的TCP连接上进行，因而避免发生全局性的拥塞控制。</p><h2 id="TCP运输连接管理"><a href="#TCP运输连接管理" class="headerlink" title="TCP运输连接管理"></a>TCP运输连接管理</h2><p>运输连接就有三个阶段，即：<strong>连接建立、数据传送和连接释放</strong>。</p><h3 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h3><p>假定主机A运行的是TCP客户程序，而B运行TCP服务器程序。最初两端的TCP进程都处于CLOSED（关闭）状态。图中在主机下面的方框分别是TCP进程所处的状态。注意，A主动打开连接，而B被动打开连接。<br><img src="/posts/3544708607/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5.png" class="" title="三次握手建立TCP连接"><br>B的TCP服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。<br>A的TCP客户进程也是首先创建传输控制模块TCB，然后向B发出连接请求报文段，这时首部中的同步位SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN报文段（即SYN = 1的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT（同步已发送）状态。<br>B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack = x + 1，同时也为自己选择一个初始序号seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入SYN-RCVD（同步收到）状态。<br>TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack = y + 1，而自己的序号seq = x + 1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq = x + 1。这时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。当B收到A的确认后，也进入ESTABLISHED状态。</p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><img src="/posts/3544708607/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BETCP%E8%BF%9E%E6%8E%A5.png" class="" title="四次挥手释放TCP连接"><p>数据传输结束后，通信的双方都可释放连接。现在A和B都处于ESTABLISHED状态​。A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FIN置1，其序号seq = u，它等于前面已传送过的数据的最后一个字节的序号加1。这时A进入FIN-WAIT-1（终止等待1）状态，等待B的确认。请注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。<br>B收到连接释放报文段后即发出确认，确认号是ack = u + 1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭(half-close)状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一些时间。<br>A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN = 1。现假定B的序号为w（在半关闭状态B可能又发送了一些数据）​。B还必须重复上次已发送过的确认号ack = u + 1。这时B就进入LAST-ACK（最后确认）状态，等待A的确认。<br>A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack = w + 1，而自己的序号是seq = u + 1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）​。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命(Maximum Segment Lifetime)，TCP允许不同的实现可根据具体情况使用更小的MSL值。因此，从A进入到TIME-WAIT状态后，要经过4分钟才能进入到CLOSED状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。</p><h3 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h3><img src="/posts/3544708607/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" class="" title="TCP的有限状态机"><p>其中，粗虚线箭头表示对服务器进程的正常变迁。另一种细线箭头表示异常变迁。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《计算机网络（第8版）》谢希仁</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> UDP/TCP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏中的网络通信（一）网络通信基础</title>
      <link href="/posts/3386282172/"/>
      <url>/posts/3386282172/</url>
      
        <content type="html"><![CDATA[<!-- ![](http://i0.hdslb.com/bfs/new_dyn/05f2c24af9bf9966872bb3003dc3cfca479331.jpg) --><p>文章首先讲解了计算机网络的五层体系结构，重点分析了运输层的作用——为应用进程之间提供端到端通信，通过端口实现复用和分用功能。对比了UDP协议和TCP协议这两个主要的运输层协议。<br><span id="more"></span></p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>计算机网络的体系结构常被分为<code>OSI七层体系结构</code>或<code>TCP/IP四层体系结构</code>。其中，OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。TCP/IP体系结构则不同，它现在已经得到了非常广泛的应用。在谢希仁编著的《计算机网络》中，综合OSI和TCP/IP的优点，采用了一种只有五层协议的体系结构。<br><img src="/posts/3386282172/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" class="" title="计算机网络体系结构"></p><ol><li>应用层：报文<br>应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。这里的进程(process)就是指主机中正在运行的程序。对于不同的网络应用需要有不同的应用层协议。在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持文件传送的FTP协议，等等。我们将应用层交互的数据单元称为<strong>报文</strong>(message)。</li><li>运输层：报文段/用户数据段<br>运输层的任务就是负责向两个主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。所谓通用，是指并不针对某个特定网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用与复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。<br>运输层主要使用以下两种协议：<ul><li>传输控制协议TCP (Transmission Control Protocol)—提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>(segment)</li><li>用户数据报协议 UDP (User Datagram Protocol)—提供无连接的、尽最大努力(best-effort)的数据传输服务（不保证数据传输的可靠性）​，其数据传输的单位是<strong>用户数据报</strong>。</li></ul></li><li>网络层：数据报<br>网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包(packet)进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作 IP数据报，或简称为<strong>数据报</strong>(datagram)。</li><li>数据链路层：帧<br>数据链路层常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成<strong>帧</strong>（framing）​，在两个相邻结点间的链路上传送帧（frame）​。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）​。</li><li>物理层：比特<br>在物理层上所传数据的单位是<strong>比特</strong>。发送方发送1（或0）时，接收方应当收到1（或0）而不是0（或1）​。因此物理层要考虑用多大的电压代表“1”或“0”​，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各条引脚应如何连接。当然，解释比特代表的意思，就不是物理层的任务。请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。因此也有人把物理媒体当作第0层。</li></ol><img src="/posts/3386282172/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B.png" class="" title="数据在各层之间的传递过程"><p>游戏作为应用层的进程，游戏开发中的网络通信主要涉及到其下一层，运输层的技术，下面将详细解析一下网络体系结构中的运输层技术。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h3><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。<br>运输层提供了这样一种抽象，其上层的应用层只要把报文交给下面的运输层，运输层就可以把这报文传送到对方的运输层​，好像这种通信就是沿水平方向直接传送数据，他对上层隐藏了具体的通信细节。</p><h3 id="为什么需要运输层？"><a href="#为什么需要运输层？" class="headerlink" title="为什么需要运输层？"></a>为什么需要运输层？</h3><p>从网络IP层来说，通信的两端是两个主机。IP数据报的首部明确地标志了这两个主机的IP地址。但“两个主机之间的通信”这种说法还不够清楚。这是因为，真正进行通信的实体是在主机中的进程，是这个主机中的一个进程和另一个主机中的一个进程在交换数据（即通信）​。因此严格地讲，两个主机进行通信就是两个主机中的应用进程互相通信。IP协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。<br>从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。在一个主机中经常有多个应用进程同时分别和另一个主机中的多个应用进程通信。这表明运输层有一个很重要的功能—复用(multiplexing)和分用(demultiplexing)。这里的“复用”是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部）​，而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。<br>简单的说，网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信，这是运输层区别于网络层的最大特征。</p><h3 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h3><ul><li>用户数据报协议UDP (User Datagram Protocol) [RFC 768]</li><li>传输控制协议TCP (Transmission Control Protocol) [RFC 793]<br>UDP在传送数据之前不需要先建立连接。远地主机的运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。<br>TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。<br>之后会详细讲解这两个协议。<h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3>端口是运输层提供的功能，在运输层之下不存在端口这个概念。端口的作用是为了实现前面说的“复用”和“分用”功能。应用层所有的应用进程都可以通过运输层再传送到IP层（网络层）​，这就是复用。<br>运输层从IP层收到数据后必须交付指明的应用进程。这就是分用。显然，给应用层的每个应用进程赋予一个非常明确的标志是至关重要的，而端口就是这个标志。<br>在UDP和TCP的首部格式中，它们都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用进程。<br>这和我们寄信的过程类似。当我们要给某人写信时，就必须知道他的通信地址。在信封上还写明自己的地址。当收信人回信时，很容易在信封上找到发信人的地址。因特网上的计算机通信是采用客户-服务器方式。客户在发起通信请求时，必须先知道对方服务器的IP地址和端口号。</li></ul><p>TCP/IP的运输层用一个16位端口号来标志一个端口。16位的端口号可允许有65535($2^{16}-1$)个不同的端口号。<br>端口号的分类：</p><ol><li>服务器端使用的端口号这里又分为两类<ol><li>最重要的一类叫做熟知端口号或系统端口号，数值为0～1023。这些数值可在网址www.iana.org查到。IANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。比如HTTP应用的端口号是80，SSH的端口号是22。</li><li>另一类叫做登记端口号，数值为1024～49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。比如MySql的默认端口号是3306.</li></ol></li><li>客户端使用的端口号数值为49152～65535。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做短暂端口号。这类端口号是留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已使用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。</li></ol><h2 id="UDP-TCP协议"><a href="#UDP-TCP协议" class="headerlink" title="UDP/TCP协议"></a>UDP/TCP协议</h2><p>在游戏开发中，对于对实时性要求高的游戏类型，相对较少使用TCP协议，但是常在应用层执行一些自定义操作来给UDP协议增加自己需要的功能，比如实现可靠的UDP协议，部分对可靠性要求高的游戏类型则常使用TCP，比如卡牌对战类游戏等。</p><h3 id="UDP协议概述"><a href="#UDP协议概述" class="headerlink" title="UDP协议概述"></a>UDP协议概述</h3><p>用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能。<br>UDP的主要特点：</p><ol><li>UDP是无连接的，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放）​，因此减少了开销和发送数据之前的时延。</li><li>UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表​。</li><li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li><li>UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。</li><li>UDP支持一对一、一对多、多对一和多对多的交互通信。</li><li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ol><p>可见UDP协议只在网络层之上增加了必要的部分功能，在使用UDP协议的应用层还可以自定义实现可靠交付、拥塞控制等各种定制化功能。</p><h3 id="UDP协议首部格式"><a href="#UDP协议首部格式" class="headerlink" title="UDP协议首部格式"></a>UDP协议首部格式</h3><img src="/posts/3386282172/UDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E9%A6%96%E9%83%A8%E5%92%8C%E4%BC%AA%E9%A6%96%E9%83%A8.png" class="" title="UDP用户数据报的首部和伪首部"><ol><li>源端口：源端口号。在需要对方回信时选用。不需要时可用全0。</li><li>目的端口：目的端口号。这在终点交付报文时必须要使用到。</li><li>长度：UDP用户数据报的长度，其最小值是8（仅有首部）​。</li><li>检验和：检测UDP用户数据报在传输中是否有错，有错就丢弃。在计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。</li></ol><h3 id="TCP协议概述"><a href="#TCP协议概述" class="headerlink" title="TCP协议概述"></a>TCP协议概述</h3><p>TCP的主要特点：</p><ol><li>TCP是面向连接的运输层协议。这就是说，应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。</li><li>每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的（一对一）​。</li><li>TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。</li><li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。</li><li>面向字节流。TCP中的“流”(stream)指的是流入到进程或从进程流出的字节序列。​。TCP并不关心应用进程一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送的报文长度是应用进程给出的）​。如果应用进程传送到TCP缓存的数据块太长，TCP就可以把它划分短一些再传送。如果应用进程一次只发来一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</li></ol><h3 id="TCP协议首部格式"><a href="#TCP协议首部格式" class="headerlink" title="TCP协议首部格式"></a>TCP协议首部格式</h3><img src="/posts/3386282172/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" class="" title="TCP报文段的首部格式"><ol><li>源端口和目的端口 各占2个字节，分别写入源端口号和目的端口号。TCP的分用功能也是通过端口实现的。</li><li>序号 占4字节。序号范围是$[0,2^{32}-1]$​，共 $2^{32}$（4294967296）个序号。<br>序号增加到232 - 1后，下一个序号就又回到0。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。<br>例如，一报文段的序号字段值是301，而携带的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的名称也叫做“报文段序号”​。</li><li>确认号 占4字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号 = N，则表明：到序号N - 1为止的所有数据都已正确收到。<br>例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501～700）​，这表明B正确收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。请注意，现在的确认号不是501，也不是700，而是701。</li><li>数据偏移 占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。</li><li>保留 占6位，保留为今后使用，但目前应置为0。</li><li>紧急URG (URGent) 当URG = 1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不要按原来的排队顺序来传送。</li><li>确认ACK (ACKnowlegment) 仅当ACK = 1时确认号字段才有效。当ACK = 0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</li><li>推送 PSH (PuSH)当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。接收方TCP收到PSH = 1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li><li>复位RST (ReSeT)当RST = 1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因）​，必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。</li><li>同步SYN (SYNchronization) 在连接建立时用来同步序号。当SYN = 1而ACK = 0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN = 1和ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。</li><li>终止FIN (FINis) 用来释放一个连接。当FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li><li>窗口 占2字节。窗口值是$[0, 2^{16} - 1]$之间的整数。窗口字段明确指出了现在允许对方发送的数据量。窗口值是经常在动态变化着。</li><li>检验和 占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式与图5-5中UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）​，把第5字段中的UDP长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。<br>这里，伪首部的第4个字段是指IP协议号。除了17号UDP协议、6号TCP协议外，还有1号协议ICMP控制消息、41号协议IPv6协议等等。</li><li>紧急指针 占2字节。紧急指针仅在URG = 1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）​。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。</li><li>选项 长度可变，最长可达40字节。当没有使用“选项”时，TCP的首部长度是20字节。这部分影响数据偏移字段的大小。</li></ol><p>在 选项 字段中，包括最大报文段长度选项 MSS (Maximum Segment Size)、窗口扩大选项、时间戳选项、选择确认选项等。这里仅介绍比较重要的时间戳选项，和选择确认选项。</p><ul><li>时间戳选项：<br> 时间戳选项占10字节，其中最主要的字段时间戳值字段（4字节）和时间戳回送回答字段（4字节）​。时间戳选项有以下两个功能：<ol><li>用来计算往返时间RTT​。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。</li><li>用于处理TCP序号超过$2^{32}$的情况，这又称为防止序号绕回 PAWS (Protect Against Wrapped Sequence numbers)。序号只有32位，而每增加$2^{32}$个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能会被重复使用。例如，若用1Gb/s的速率发送报文段，则不到35秒钟数据字节的序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。</li></ol></li><li>选择确认选项：<br>选择确认SACK选项用来解决这样一个问题，这个问题是若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？<br>使用选择确认功能的TCP协议通过一个字节来指明是否允许选择确认，一个字节指明这个选项占用多少字节，其余字节用来指明收到的字节块左右边界位置，这样接受方就不会重传收到字节块内的数据了。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《计算机网络（第8版）》谢希仁</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> UDP/TCP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#性能优化基础</title>
      <link href="/posts/577437014/"/>
      <url>/posts/577437014/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.hdslb.com/bfs/new_dyn/5cf322055745e6537ae8186e7aed46423127575.jpg" alt=""><br>应用层面的优化变化太多，比较难总结出系统的方法，这里只结合源码介绍关于C#语言层面的性能与GC方面的优化基础知识及原理。</p><span id="more"></span><h2 id="C-的GC算法"><a href="#C-的GC算法" class="headerlink" title="C#的GC算法"></a>C#的GC算法</h2><h3 id="CLR的GC算法"><a href="#CLR的GC算法" class="headerlink" title="CLR的GC算法"></a>CLR的GC算法</h3><p>CLRGC算法是分代式标记-压缩GC，详细的算法逻辑可参考<a href="https://weread.qq.com/web/reader/710327c0718f6368710b285kec532f2027fec5decca5182">C# 7.0 核心技术指南 垃圾回收器的工作方式</a>，以下只介绍一下大概思路。</p><p>GC会从根对象开始按照对象引用遍历对象图，将所有遍历到的对象标记为可达对象。当这个过程完成之后，所有没有标记的对象（即未被使用的对象）将会作为垃圾进行回收。未被使用的对象若没有终结器，则会被立即回收。而有终结器的对象将会放到终结队列中，并在GC完成之后由终结器线程处理。这些对象将在下一次对这代对象的垃圾回收中回收（除非该对象复活）。剩余的存活对象对象将移动到堆的起始位置（压缩）​，释放出更多的对象空间来容纳更多的对象。这种压缩过程的目的有两个：它可以防止内存碎片化，并且GC可以用很简单的策略来分配新的对象，将新的对象分配在堆的尾部即可。同时，它还避免了耗时的内存片段列表的维护开销。</p><p>CLR垃圾回收器将堆上的内存分为了三代。刚刚分配的对象位于第0代；在第一轮回收中存活的对象在第1代，而其他所有对象为第2代。第0代和第1代对象是所谓的短生存期的代。<br>CLR将第0代控制在一个相对较小的空间内（在64位工作站CLR下，最大为256 MB。而通常仅有几百KB到几MB）。当第0代填满时，GC就会触发第0代垃圾回收。第0代垃圾回收会频繁发生。GC对第1代内存应用了相似空间限制（作为第2代的缓冲区）​，且第1代内存的回收也相对快速而频繁。一次完整的内存回收会包含第2代内存。但是这种回收时间较长，因此并不是那么频繁。</p><img src="/posts/577437014/%E5%88%86%E4%BB%A3%E5%BC%8F%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9GC.png" class="" title="分代式标记-压缩GC"><h3 id="IL2CPP的GC算法"><a href="#IL2CPP的GC算法" class="headerlink" title="IL2CPP的GC算法"></a>IL2CPP的GC算法</h3><p>而Unity中，IL2CPP技术的托管堆没有采用CLR的GC算法，而是采用的Boehm-Demers-Weiser Garbage Collector（贝姆垃圾收集器）。</p><p>二者区别在于，BoehmGC是无压缩、无分代的标记-清理算法。BoehmGC不会进行内存压缩，相比CLR的GC算法会有很多的内存碎片；BoehmGC不会进行分代回收，相比CLR GC算法，BoehmGC的GC频率和范围不会进行动态的修改。而BoehmGC的优点在于其更简单，占用内存更小，GC耗时也更少。一个最直接的应用，C#的<code>GC.Collect</code>函数会带一个参数<br><code>public static void Collect (int generation);</code> 表示强制对 0 代到指定代进行即时垃圾回收，如果不指定参数则会回收所有代。</p><h2 id="struct与class"><a href="#struct与class" class="headerlink" title="struct与class"></a>struct与class</h2><p>C#的GC算法是对于托管堆上的对象的，而栈上的对象在程序离开栈的时候，栈上的变量就会被直接清除，不会被GC管理。<br>和C++不一样，在C#中struct属于值类型，class属于引用类型。值类型的变量会直接存储数据，而引用类型的变量持有的是数据的引用，其真实数据存储在数据堆中（相当于C++中的指针和指针指向的对象）。<br>设想在<code>Update</code>函数中，进行对象的实例化，如果是实例化的引用对象，则会不断申请新内存，频繁触发GC。而如果是值类型，则在离开<code>Update</code>方法时，栈上所分配的空间就会被直接清除（实际上是被设置成不可见，后续如果有新分配的栈内容会直接覆盖掉）。</p><p>但是很多人认为值类型一定是分配在栈上，这是错误的。首先引用类型的对象主体一定是分配在堆上的，而对于一个值类型，如果声明在一个class类中，就分配在堆内存中。如果是非空引用类型对象（<code>int?</code>等）和所有装箱值类型对象总是分配在堆内存上。如果声明在函数的局部变量中，就分配到栈上。<br>因此，有人可能会借用对引用对象的管理经验来管理值类型，比如为了复用而把一些值类型在class中进行缓存，甚至使用对象池来管理，这实际上是得不偿失的。</p><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>把值类型实例转换为引用类型实例，就是装箱。反之，把引用类型实例转换为值类型实例，就是拆箱。举个例子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">object</span> obj = a;</span><br><span class="line"><span class="comment">// 以上就是装箱</span></span><br><span class="line"><span class="built_in">int</span> b = (<span class="built_in">int</span>)obj;</span><br><span class="line"><span class="comment">// 以上就是拆箱</span></span><br></pre></td></tr></table></figure><br>上面的例子里，obj为引用类型，指针与内存拆分开来，把a赋值给obj，实际上就是obj为自己创建了一个指针，并指向了a的数据空间。而obj指向的内存空间复制一份交给了b，因为b是值类型，所以它不允许指向某个内存空间，只能靠复制数据来传递数据。</p><p>装箱的内部操作：根据相应的值类型在堆中分配一个值类型内存块，再将数据复制给它，这会分三步进行。第一步：在堆内存中新分配一个内存块（大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex类）​。第二步：将值类型的实例字段复制到新分配的内存块中。第三步：返回内存堆中新分配对象的地址。这个地址就是一个指向对象的引用。拆箱则更为简单，先检查对象实例，确保它是给定值类型的一个装箱值，再将该值从实例复制到值类型变量的内存块中。</p><p>由于装箱、拆箱时生成的是全新的对象，不断地分配和销毁内存不但会大量消耗CPU，同时也会增加内存碎片，降低性能。</p><p>大部分时候，只有当程序、逻辑或接口需要更加通用的时候才需要装箱。比如调用一个含类型为object的参数的方法，该object可支持任意类型，以便通用。当你需要将一个值类型（如Int32）传入时，就需要装箱。又比如一个非泛型的容器为了保证通用，而将元素类型定义为object，当值类型数据加入容器时，就需要装箱。所以常常装箱拆箱发生在程序意想不到的地方。</p><h3 id="装箱拆箱的优化方法"><a href="#装箱拆箱的优化方法" class="headerlink" title="装箱拆箱的优化方法"></a>装箱拆箱的优化方法</h3><ul><li>struct通过重载函数来避免装箱拆箱。<br>比如常用的ToString()、GetType()方法，如果Struct没有写重载ToString()和GetType()的方法，就会在Struct实例调用它们时先装箱再调用，导致内存块重新分配，性能损耗，所以对于那些需要调用的引用方法，必须重载。</li><li>通过泛型来避免拆箱、装箱。<br>考虑下面一个常用的迭代器例子:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable <span class="title">GetRangeInt</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>看似很普通的返回数组的迭代器，实际上<code>IEnumerable</code>接口为了通用性，返回的是通用<code>IEnumerator</code>，其内部使用了<code>object</code>进行接口泛化，如果返回的是值类型，则会进行装箱操作。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DispId(-4)</span>]</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>而如果查看编译出来的迭代器代码，也会发现端倪<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;<span class="title">GetRangeInt</span>&gt;<span class="title">d__1</span> : <span class="title">IEnumerable</span>&lt;<span class="title">object</span>&gt;, <span class="title">IEnumerable</span>, <span class="title">IEnumerator</span>&lt;<span class="title">object</span>&gt;, <span class="title">IEnumerator</span>, <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">object</span> &lt;&gt;<span class="number">2</span>__current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> &lt;&gt;l__initialThreadId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TestIEnumerator &lt;&gt;<span class="number">4</span>__this;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> &lt;i&gt;<span class="number">5</span>__1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object</span> IEnumerator&lt;<span class="built_in">object</span>&gt;.Current</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;&gt;<span class="number">2</span>__current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">object</span> IEnumerator.Current</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;&gt;<span class="number">2</span>__current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (&lt;&gt;<span class="number">1</span>__state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">                &lt;i&gt;<span class="number">5</span>__1 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                &lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">                &lt;i&gt;<span class="number">5</span>__1++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (&lt;i&gt;<span class="number">5</span>__1 &lt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            &lt;&gt;<span class="number">2</span>__current = &lt;i&gt;<span class="number">5</span>__1;</span><br><span class="line">            &lt;&gt;<span class="number">1</span>__state = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> IEnumerator.MoveNext()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in MoveNext</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.MoveNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">    IEnumerator&lt;<span class="built_in">object</span>&gt; IEnumerable&lt;<span class="built_in">object</span>&gt;.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        &lt;GetRangeInt&gt;d__1 result;</span><br><span class="line">        <span class="keyword">if</span> (&lt;&gt;<span class="number">1</span>__state == <span class="number">-2</span> &amp;&amp; &lt;&gt;l__initialThreadId == Environment.CurrentManagedThreadId)</span><br><span class="line">        &#123;</span><br><span class="line">            &lt;&gt;<span class="number">1</span>__state = <span class="number">0</span>;</span><br><span class="line">            result = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">new</span> &lt;GetRangeInt&gt;d__1(<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                &lt;&gt;<span class="number">4</span>__this = &lt;&gt;<span class="number">4</span>__this</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IEnumerable&lt;<span class="built_in">object</span>&gt;)<span class="keyword">this</span>).GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面的代码，可以使用迭代器的泛型版本进行优化<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetRangeInt</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过继承统一的接口提前拆箱、装箱，避免多次重复拆箱、装箱。<br>很多时候拆箱、装箱不可避免，这时可以让多种Struct继承某个统一的接口，不同的Struct可以有相同的接口。把Struct传递到其他方法里，就相当于提前进行了装箱操作，在方法中得到的是引用类型的值，并且有它需要的接口，避免了在方法中完成重复多次的拆箱、装箱操作。</li></ul><h2 id="委托与事件"><a href="#委托与事件" class="headerlink" title="委托与事件"></a>委托与事件</h2><p>C#使用委托(delegate)的概念来实现函数指针的功能。<br>在创建委托时，其实就是创建一个delegate类实例，这个delegate委托类继承了<code>System.MulticastDelegate</code>类，类实例里有<code>BeginInvoke()、EndInvoke()、Invoke()</code>这三个函数，分别表示异步开始调用、结束异步调用及直接调用。<br>事实上委托delegate关键字其实只是一个修饰用词，背后是由C#编译器来重写的代码，可以认为是编译器会根据关键字创建一个新的继承了System.MulticastDelegate的类。既然是类，那就会在堆内存中分配空间，就存在GC问题。所以委托的创建不能太频繁，可以进行缓存操作。</p><p>相同的还有事件<code>event</code>，事件实际上是在委托上的又一层封装，用以限制用户直接操作delegate实例中变量的权限。关于委托的性能优化内容在事件上同样适用。</p><h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>匿名委托和Lambda表达式统称为匿名方法，实际上，Lambda表达式还是会被编译器解释为一个匿名委托。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delegatAnoymousFunctio = <span class="built_in">delegate</span> &#123; &#125;;  <span class="comment">// 匿名委托</span></span><br><span class="line"><span class="keyword">var</span> lambdaAnoymousFunction = () =&gt; &#123;&#125;;      <span class="comment">// Lambda表达式</span></span><br></pre></td></tr></table></figure><br>但是，匿名方法和普通委托不同，CLR对匿名方法进行的特别的优化，匿名方法会以内联方式放入委托对象的使用位置，而避免创建一个委托来关联回调方法，也就是由委托调用了匿名的方法。所以匿名方法避免了创建委托带来的GC。对于下面的给一个直接的例子。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Action actMember = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>()</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 0 GC</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnoymousFunctionWithoutArg</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    actMember = <span class="built_in">delegate</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有创建委托的GC</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnoymousFunctionWithStaticArg2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    actMember = Test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关于闭包"><a href="#关于闭包" class="headerlink" title="关于闭包"></a>关于闭包</h3><p>如果一个闭包捕获了外部变量，CLR会生成一个内联类来存储外部变量，关注下面的例子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnoymousFunctionWithLocalArg</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> bValue = <span class="literal">true</span>;</span><br><span class="line">    actMember = <span class="built_in">delegate</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log((<span class="built_in">object</span>)bValue);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个匿名委托由于捕获了外部变量<code>bVlaue</code>，CLR会生成下面的类：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CompilerGenerated</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;&gt;<span class="title">c__DisplayClass17_0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> bValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">void</span> &lt;AnoymousFunctionWithLocalArg&gt;b__0()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log((<span class="built_in">object</span>)bValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后将类的实例加入到委托中，而这会造成类实例化的堆内存分配。<br><strong>所以，对于闭包而言，会有额外的堆内存分配。</strong></p><h3 id="关于Linq"><a href="#关于Linq" class="headerlink" title="关于Linq"></a>关于Linq</h3><p>很多人认为委托或者匿名方法会带来GC，所以自然认为Linq会因此导致不小的GC。这是完全错误的，大部分Linq会带来GC，但是并不是匿名方法带来的。考虑下面的简单Linq例子。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void MyLinq()</span><br><span class="line">&#123;</span><br><span class="line">    list.Where(()=&gt;x&gt;5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的Lambda表达式不会产生GC，真正产生GC的，是<code>Where</code>函数:<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">TSource</span>&gt; <span class="title">Where</span>&lt;<span class="title">TSource</span>&gt;(<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, Func&lt;TSource, <span class="built_in">bool</span>&gt; predicate</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">null</span>) <span class="keyword">throw</span> Error.ArgumentNull(<span class="string">&quot;source&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (predicate == <span class="literal">null</span>) <span class="keyword">throw</span> Error.ArgumentNull(<span class="string">&quot;predicate&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="function">source <span class="keyword">is</span> <span class="title">Iterator</span>&lt;<span class="title">TSource</span>&gt;) <span class="title">return</span> (<span class="params">(Iterator&lt;TSource&gt;</span>)source).<span class="title">Where</span>(<span class="params">predicate</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">is</span> TSource[]) <span class="keyword">return</span> <span class="keyword">new</span> WhereArrayIterator&lt;TSource&gt;((TSource[])source, predicate);</span><br><span class="line">    <span class="keyword">if</span> (<span class="function">source <span class="keyword">is</span> <span class="title">List</span>&lt;<span class="title">TSource</span>&gt;) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WhereListIterator</span>&lt;<span class="title">TSource</span>&gt;(<span class="params">(List&lt;TSource&gt;</span>)source, predicate)</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WhereEnumerableIterator&lt;TSource&gt;(source, predicate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">WhereEnumerableIterator</span>&lt;<span class="title">TSource</span>&gt; : <span class="title">Iterator</span>&lt;<span class="title">TSource</span>&gt; &#123;<span class="comment">/*...*/</span>&#125;</span><br></pre></td></tr></table></figure><br>Where函数内部会生成一个迭代器，内存分配出现在了这里，其他大部分Linq也是类似，只要Linq中没有闭包，那么产生的GC都在Linq函数本身。</p><h2 id="C-的常用基础库分析"><a href="#C-的常用基础库分析" class="headerlink" title="C#的常用基础库分析"></a>C#的常用基础库分析</h2><h3 id="String源码分析"><a href="#String源码分析" class="headerlink" title="String源码分析"></a>String源码分析</h3><ul><li><p>为什么应该避免字符串拼接？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Concat</span>(<span class="params">String str0, String str1</span>)</span> &#123;</span><br><span class="line">    Contract.Ensures(Contract.Result&lt;String&gt;() != <span class="literal">null</span>);</span><br><span class="line">    Contract.Ensures(Contract.Result&lt;String&gt;().Length ==</span><br><span class="line">        (str0 == <span class="literal">null</span> ? <span class="number">0</span> : str0.Length) +</span><br><span class="line">        (str1 == <span class="literal">null</span> ? <span class="number">0</span> : str1.Length));</span><br><span class="line">    Contract.EndContractBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsNullOrEmpty(str0)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsNullOrEmpty(str1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsNullOrEmpty(str1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> str0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> str0Length = str0.Length;</span><br><span class="line">    </span><br><span class="line">    String result = FastAllocateString(str0.Length + str1.Length);</span><br><span class="line">    </span><br><span class="line">    FillStringChecked(result, <span class="number">0</span>,        str0);</span><br><span class="line">    FillStringChecked(result, str0Length, str1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#托管代码没有实现对string加法的重载，string加法实际是作为一种语法糖存在，会被编译器优化为<code>String.Concat</code>，而对于一些常量字符串的拼接，编译器会直接优化为拼接好的字符串。不过如源码所示，每次进行拼接都会分配一块新内存空间来进行填充，所以每次拼接都会生成GC碎片。所以更好的实践是使用String.Format、内插字符串或者StringBuilder来进行字符串拼接，后续会再讲到，这三种方式本质都是使用StringBuilder。</p></li><li><p>String驻留池</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Intern</span>(<span class="params">String str</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Contract.Ensures(Contract.Result&lt;String&gt;().Length == str.Length);</span><br><span class="line">    Contract.Ensures(str.Equals(Contract.Result&lt;String&gt;()));</span><br><span class="line">    Contract.EndContractBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Thread.GetDomain().GetOrInternString(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CLR通过维护一个名为驻留池的表来节省字符串存储，该表包含对程序中声明或通过编程方式创建的每个唯一文本字符串的单一引用。 因此，具有特定值的文字字符串的实例仅在系统中存在一次。 例如，如果将相同的文本字符串分配给多个变量，运行时将从驻留池中检索对文本字符串的相同引用，并将其分配给每个变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;MyTest&quot;</span>; </span><br><span class="line"><span class="built_in">string</span> s2 = <span class="keyword">new</span> StringBuilder().Append(<span class="string">&quot;My&quot;</span>).Append(<span class="string">&quot;Test&quot;</span>).ToString(); </span><br><span class="line"><span class="comment">// s2通过StringBuilder已经分配出了一个新内存空间了，所以不可能和驻留池里的引用一致。</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">&quot;MyTest&quot;</span>; </span><br><span class="line">Console.WriteLine((Object)s2==(Object)s1); <span class="comment">// False.</span></span><br><span class="line">Console.WriteLine((Object)s3==(Object)s1); <span class="comment">// True.</span></span><br></pre></td></tr></table></figure><p>驻留池的副作用：</p></li></ul><ol><li>在 CLR 终止之前，为驻留 String 对象分配的内存通常不会被释放。 原因是 CLR 对驻留对象 String 的引用可能在应用程序甚至应用程序域终止后仍然存在。 </li><li>要在内存中驻留字符串，必须先创建字符串。使用String对象的内存仍必须进行分配，即使该内存最终会被垃圾回收。</li></ol><p>对于大型项目而言，CLR自带的驻留池不是一个好的选项，因为它会将项目中所有const字符串都执行驻留操作，而且一般不会释放，更好的实践是自己创建驻留池，或使用语言表统筹项目内的所有字符串。</p><ul><li>StringBuilder和内插字符串<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.cs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">FormatHelper</span>(<span class="params">IFormatProvider provider, String format, ParamsArray <span class="keyword">args</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (format == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;format&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> StringBuilderCache.GetStringAndRelease(</span><br><span class="line">        StringBuilderCache</span><br><span class="line">            .Acquire(format.Length + <span class="keyword">args</span>.Length * <span class="number">8</span>)</span><br><span class="line">            .AppendFormatHelper(provider, format, <span class="keyword">args</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuilderCache.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">Acquire</span>(<span class="params"><span class="built_in">int</span> capacity = StringBuilder.DefaultCapacity</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(capacity &lt;= MAX_BUILDER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = StringBuilderCache.CachedInstance;</span><br><span class="line">        <span class="keyword">if</span> (sb != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Avoid stringbuilder block fragmentation by getting a new StringBuilder</span></span><br><span class="line">            <span class="comment">// when the requested size is larger than the current capacity</span></span><br><span class="line">            <span class="keyword">if</span>(capacity &lt;= sb.Capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                StringBuilderCache.CachedInstance = <span class="literal">null</span>;</span><br><span class="line">                sb.Clear();</span><br><span class="line">                <span class="keyword">return</span> sb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>内插字符串是String.Format的语法糖，最后还是会被编译器编译为String.Format。而String.Format如上述代码所示还是会调用到StringBuilder。这里使用了StringBuilderCache缓存的StringBuilder对象，StringBuilderCache相当于一个该线程内只包含一个StringBuilder对象的对象池，这一般已经足够了，所以有的代码会使用对象池去管理StringBuilder对象（YIUI的源码就设计了一个StringBuilder对象池），这其实可以用StringBuilderCache代替。<br>而StringBuilder进行无GC的字符串拼接原理，如下源码所示：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> StringBuilder m_ChunkPrevious;      <span class="comment">// Link to the block logically before this block</span></span><br><span class="line"><span class="keyword">internal</span> <span class="built_in">char</span>[] m_ChunkChars;                <span class="comment">// The characters in this block</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> StringBuilder <span class="title">Append</span>(<span class="params"><span class="built_in">char</span>* <span class="keyword">value</span>, <span class="built_in">int</span> valueCount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We don&#x27;t check null value as this case will throw null reference exception anyway</span></span><br><span class="line">    <span class="keyword">if</span> (valueCount &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;valueCount&quot;</span>, Environment.GetResourceString(<span class="string">&quot;ArgumentOutOfRange_NegativeCount&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This case is so common we want to optimize for it heavily. </span></span><br><span class="line">    <span class="built_in">int</span> newIndex = valueCount + m_ChunkLength;</span><br><span class="line">    <span class="keyword">if</span> (newIndex &lt;= m_ChunkChars.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadSafeCopy(<span class="keyword">value</span>, m_ChunkChars, m_ChunkLength, valueCount);</span><br><span class="line">        m_ChunkLength = newIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Copy the first chunk</span></span><br><span class="line">        <span class="built_in">int</span> firstLength = m_ChunkChars.Length - m_ChunkLength;</span><br><span class="line">        <span class="keyword">if</span> (firstLength &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ThreadSafeCopy(<span class="keyword">value</span>, m_ChunkChars, m_ChunkLength, firstLength);</span><br><span class="line">            m_ChunkLength = m_ChunkChars.Length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expand the builder to add another chunk. </span></span><br><span class="line">        <span class="built_in">int</span> restLength = valueCount - firstLength;</span><br><span class="line">        ExpandByABlock(restLength);</span><br><span class="line">        Contract.Assert(m_ChunkLength == <span class="number">0</span>, <span class="string">&quot;Expand did not make a new block&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy the second chunk</span></span><br><span class="line">        ThreadSafeCopy(<span class="keyword">value</span> + firstLength, m_ChunkChars, <span class="number">0</span>, restLength);</span><br><span class="line">        m_ChunkLength = restLength;</span><br><span class="line">    &#125;</span><br><span class="line">    VerifyClassInvariant();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> String <span class="title">ToString</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Contract.Ensures(Contract.Result&lt;String&gt;() != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    VerifyClassInvariant();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> String.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ret = <span class="built_in">string</span>.FastAllocateString(Length);</span><br><span class="line">    StringBuilder chunk = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">unsafe</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fixed</span> (<span class="built_in">char</span>* destinationPtr = ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (chunk.m_ChunkLength &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Copy these into local variables so that they are stable even in the presence of ----s (hackers might do this)</span></span><br><span class="line">                    <span class="built_in">char</span>[] sourceArray = chunk.m_ChunkChars;</span><br><span class="line">                    <span class="built_in">int</span> chunkOffset = chunk.m_ChunkOffset;</span><br><span class="line">                    <span class="built_in">int</span> chunkLength = chunk.m_ChunkLength;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Check that we will not overrun our boundaries. </span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="built_in">uint</span>)(chunkLength + chunkOffset) &lt;= ret.Length &amp;&amp; (<span class="built_in">uint</span>)chunkLength &lt;= (<span class="built_in">uint</span>)sourceArray.Length)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">fixed</span> (<span class="built_in">char</span>* sourcePtr = sourceArray)</span><br><span class="line">                            <span class="built_in">string</span>.wstrcpy(destinationPtr + chunkOffset, sourcePtr, chunkLength);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;chunkLength&quot;</span>, Environment.GetResourceString(<span class="string">&quot;ArgumentOutOfRange_Index&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                chunk = chunk.m_ChunkPrevious;</span><br><span class="line">            &#125; <span class="keyword">while</span> (chunk != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到StringBuilder实际上是一个char类型的数组，<code>Append</code>实际上是向数组中添加新char元素。而因此StringBuilder也会出现扩容问题，其会以链表的形式，再开辟一块StringBuilder将其引用保存到本对象的<code>m_ChunkPrevious</code>中，所以相关的最佳实践是在业务层第一次创建StringBuilder的时候就将需要的字符数量设置好，避免引发扩容。<br>而<code>ToString</code>方法还是会分配一片属于这个字符串的空间，并使用指针进行快速内存复制。但字符串结果并且没有缓存，如果需要频繁使用<code>StringBuilder.ToString</code>的结果最好进行业务层的缓存。</li></ul><h3 id="List源码分析"><a href="#List源码分析" class="headerlink" title="List源码分析"></a>List源码分析</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; : <span class="title">IList</span>&lt;<span class="title">T</span>&gt;, System.Collections.IList, <span class="title">IReadOnlyList</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] _items;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _size;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Capacity &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            Contract.Ensures(Contract.Result&lt;<span class="built_in">int</span>&gt;() &gt;= <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> _items.Length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> &lt; _size) &#123;</span><br><span class="line">                ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.<span class="keyword">value</span>, ExceptionResource.ArgumentOutOfRange_SmallCapacity);</span><br><span class="line">            &#125;</span><br><span class="line">            Contract.EndContractBlock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> != _items.Length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">value</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    T[] newItems = <span class="keyword">new</span> T[<span class="keyword">value</span>];</span><br><span class="line">                    <span class="keyword">if</span> (_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Array.Copy(_items, <span class="number">0</span>, newItems, <span class="number">0</span>, _size);</span><br><span class="line">                    &#125;</span><br><span class="line">                    _items = newItems;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    _items = _emptyArray;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_size == _items.Length) EnsureCapacity(_size + <span class="number">1</span>);</span><br><span class="line">        _items[_size++] = item;</span><br><span class="line">        _version++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T item</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Note that insertions at the end are legal.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">uint</span>) index &gt; (<span class="built_in">uint</span>)_size) &#123;</span><br><span class="line">            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);</span><br><span class="line">        &#125;</span><br><span class="line">        Contract.EndContractBlock();</span><br><span class="line">        <span class="keyword">if</span> (_size == _items.Length) EnsureCapacity(_size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; _size) &#123;</span><br><span class="line">            Array.Copy(_items, index, _items, index + <span class="number">1</span>, _size - index);</span><br><span class="line">        &#125;</span><br><span class="line">        _items[index] = item;</span><br><span class="line">        _size++;            </span><br><span class="line">        _version++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensures that the capacity of this list is at least the given minimum</span></span><br><span class="line">    <span class="comment">// value. If the currect capacity of the list is less than min, the</span></span><br><span class="line">    <span class="comment">// capacity is increased to twice the current capacity or to min,</span></span><br><span class="line">    <span class="comment">// whichever is larger.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnsureCapacity</span>(<span class="params"><span class="built_in">int</span> min</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_items.Length &lt; min) &#123;</span><br><span class="line">            <span class="built_in">int</span> newCapacity = _items.Length == <span class="number">0</span>? _defaultCapacity : _items.Length * <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.</span></span><br><span class="line">            <span class="comment">// Note that this check works even when _items.Length overflowed thanks to the (uint) cast</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">uint</span>)newCapacity &gt; Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &lt; min) newCapacity = min;</span><br><span class="line">            Capacity = newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">T item</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> index = IndexOf(item);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            RemoveAt(index);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">uint</span>)index &gt;= (<span class="built_in">uint</span>)_size) &#123;</span><br><span class="line">            ThrowHelper.ThrowArgumentOutOfRangeException();</span><br><span class="line">        &#125;</span><br><span class="line">        Contract.EndContractBlock();</span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; _size) &#123;</span><br><span class="line">            Array.Copy(_items, index + <span class="number">1</span>, _items, index, _size - index);</span><br><span class="line">        &#125;</span><br><span class="line">        _items[_size] = <span class="literal">default</span>(T);</span><br><span class="line">        _version++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Find</span>(<span class="params">Predicate&lt;T&gt; match</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( match == <span class="literal">null</span>) &#123;</span><br><span class="line">            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.match);</span><br><span class="line">        &#125;</span><br><span class="line">        Contract.EndContractBlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ; i &lt; _size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(match(_items[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> _items[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">default</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到C#的List容器在原理上和C++的Vector类似，其实质上是一个可扩容的数组结构。<br>在进行元素的增加和插入时，容器会首先判断是否达到了数组容量上限，如果达到上限了则数组容量会扩充一倍。_defaultCapacity表示容量的默认值为4。因此，如果没有在初始化时自定义数组的初始容量，则整个扩充的路线为4、8、16、32、64、128、256、512、1024……以此类推。扩容时会重新生成一个新容量的数组，并抛弃原数组。所以如果容器的元素数量在$2^{n}+1$的话，如果不加以控制，会有近一半的空间被浪费，尽量在初始化时设置一个合适的容量值，是减少List容器扩容的重要优化手段。<br>在进行元素的删除和查找时，<code>List</code>容器的时间复杂度也是$O(n)$的，不过如果该列表是有序的，则可以用<code>List.BinarySearch</code>进行二分查找。<br>可以发现<code>List</code>容器除了索引查找外，其他的功能效率并不高，这个容器只是通用性比较强。在性能敏感场景下的使用需要格外小心。</p><h3 id="Dictionary源码分析"><a href="#Dictionary源码分析" class="headerlink" title="Dictionary源码分析"></a>Dictionary源码分析</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dictionary</span>&lt;<span class="title">TKey</span>,<span class="title">TValue</span>&gt;: <span class="title">IDictionary</span>&lt;<span class="title">TKey</span>,<span class="title">TValue</span>&gt;, <span class="title">IDictionary</span>, <span class="title">IReadOnlyDictionary</span>&lt;<span class="title">TKey</span>, <span class="title">TValue</span>&gt;, <span class="title">ISerializable</span>, <span class="title">IDeserializationCallback</span>  &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> Entry &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> hashCode;    <span class="comment">// Lower 31 bits of hash code, -1 if unused</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> next;        <span class="comment">// Index of next entry, -1 if last</span></span><br><span class="line">        <span class="keyword">public</span> TKey key;           <span class="comment">// Key of entry</span></span><br><span class="line">        <span class="keyword">public</span> TValue <span class="keyword">value</span>;         <span class="comment">// Value of entry</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] buckets;</span><br><span class="line">    <span class="keyword">private</span> Entry[] entries;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> freeList;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> freeCount;</span><br><span class="line">    <span class="keyword">private</span> IEqualityComparer&lt;TKey&gt; comparer;</span><br><span class="line">    <span class="keyword">private</span> KeyCollection keys;</span><br><span class="line">    <span class="keyword">private</span> ValueCollection values;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> size = HashHelpers.GetPrime(capacity);</span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="built_in">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buckets.Length; i++) buckets[i] = <span class="number">-1</span>;</span><br><span class="line">        entries = <span class="keyword">new</span> Entry[size];</span><br><span class="line">        freeList = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params">TKey key, TValue <span class="keyword">value</span>, <span class="built_in">bool</span> <span class="keyword">add</span></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( key == <span class="literal">null</span> ) &#123;</span><br><span class="line">            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buckets == <span class="literal">null</span>) Initialize(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">int</span> hashCode = comparer.GetHashCode(key) &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">        <span class="built_in">int</span> targetBucket = hashCode % buckets.Length;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FEATURE_RANDOMIZED_STRING_HASHING</span></span><br><span class="line">        <span class="built_in">int</span> collisionCount = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = buckets[targetBucket]; i &gt;= <span class="number">0</span>; i = entries[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">add</span>) &#123; </span><br><span class="line">                    ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);</span><br><span class="line">                &#125;</span><br><span class="line">                entries[i].<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                version++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FEATURE_RANDOMIZED_STRING_HASHING</span></span><br><span class="line">            collisionCount++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> index;</span><br><span class="line">        <span class="keyword">if</span> (freeCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = freeList;</span><br><span class="line">            freeList = entries[index].next;</span><br><span class="line">            freeCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == entries.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                Resize();</span><br><span class="line">                targetBucket = hashCode % buckets.Length;</span><br><span class="line">            &#125;</span><br><span class="line">            index = count;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entries[index].hashCode = hashCode;</span><br><span class="line">        entries[index].next = buckets[targetBucket];</span><br><span class="line">        entries[index].key = key;</span><br><span class="line">        entries[index].<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">        buckets[targetBucket] = index;</span><br><span class="line">        version++;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FEATURE_RANDOMIZED_STRING_HASHING</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FEATURE_CORECLR</span></span><br><span class="line">        <span class="comment">// In case we hit the collision threshold we&#x27;ll need to switch to the comparer which is using randomized string hashing</span></span><br><span class="line">        <span class="comment">// in this case will be EqualityComparer&lt;string&gt;.Default.</span></span><br><span class="line">        <span class="comment">// Note, randomized string hashing is turned on by default on coreclr so EqualityComparer&lt;string&gt;.Default will </span></span><br><span class="line">        <span class="comment">// be using randomized string hashing</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; comparer == NonRandomizedStringEqualityComparer.Default) </span><br><span class="line">        &#123;</span><br><span class="line">            comparer = (IEqualityComparer&lt;TKey&gt;) EqualityComparer&lt;<span class="built_in">string</span>&gt;.Default;</span><br><span class="line">            Resize(entries.Length, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span>(collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; HashHelpers.IsWellKnownEqualityComparer(comparer)) </span><br><span class="line">        &#123;</span><br><span class="line">            comparer = (IEqualityComparer&lt;TKey&gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);</span><br><span class="line">            Resize(entries.Length, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> // FEATURE_CORECLR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">TKey key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="literal">null</span>) &#123;</span><br><span class="line">            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buckets != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> hashCode = comparer.GetHashCode(key) &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">            <span class="built_in">int</span> bucket = hashCode % buckets.Length;</span><br><span class="line">            <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = buckets[bucket]; i &gt;= <span class="number">0</span>; last = i, i = entries[i].next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buckets[bucket] = entries[i].next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        entries[last].next = entries[i].next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    entries[i].hashCode = <span class="number">-1</span>;</span><br><span class="line">                    entries[i].next = freeList;</span><br><span class="line">                    entries[i].key = <span class="literal">default</span>(TKey);</span><br><span class="line">                    entries[i].<span class="keyword">value</span> = <span class="literal">default</span>(TValue);</span><br><span class="line">                    freeList = i;</span><br><span class="line">                    freeCount++;</span><br><span class="line">                    version++;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上只给出了<code>Dictionary</code>容器的基础增删功能。可以看出，C#的Dictionary实现使用了两个数组，一个桶数组，一个具体元素数组，具体两个数组的关系如下图所示：</p><img src="/posts/577437014/Dictionary%E5%AE%B9%E5%99%A8.svg" class="" title="Dictionary容器"><p>容器使用拉链法处理哈希冲突，并使用质数容量来实现Hash值的均匀分布。其中，容器没有根据装填因子来进行扩容，而是直接判断具体元素数组是否达到上限，如果到上限则扩容到原容量x2的最小质数容量。这会带来整个容器的重构。而容器的删除操作只会将其单元格置空，不会真正删除，<code>Clear</code>函数也类似。所以和List容器类似，在初始化时应该给予一个适当的容器大小，<strong>来避免多次扩容</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> C# </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity协程（一）进程、线程与协程</title>
      <link href="/posts/758291315/"/>
      <url>/posts/758291315/</url>
      
        <content type="html"><![CDATA[<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>对于应用层而言，进程、线程与协程都是为了实现并发和并行的技术手段。<br><!-- ![](https://i0.hdslb.com/bfs/new_dyn/ae27f87606591cb8f09c477bc42464353127575.jpg) --><br><span id="more"></span></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>进程是具有独立功能的可并发执行的程序在一个数据集合上的运行过程，是系统进行资源分配和调度的独立单位。</strong> 可以把它理解为一个 “正在运行的程序”。当一个程序（如浏览器、Word）启动时，操作系统就会为它创建一个进程。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在多道操作系统中，程序的执行属于并发执行，如果没有进程对每个程序进行封装，他们将失去其封闭性，并具有间断性、运行结果不可再现的特性，为能使程序并发执行，并且可以对并发执行的程序加一描述和控制，就需要引入进程这个概念。</p><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><ul><li>资源独立： 每个进程都拥有自己独立的内存空间（代码段、数据段、堆、栈）、文件描述符、环境变量、安全属性等。一个进程崩溃通常不会直接影响其他进程（稳定性好）。</li><li>重量级： 创建、销毁、切换进程需要操作系统内核进行复杂的操作（分配/回收内存、寄存器保存/恢复等），开销较大。</li><li>通信开销大： 进程间通信需要特定的机制，因为内存不共享。常见方式有：管道、消息队列、共享内存（需同步）、套接字等。这些机制通常比线程间通信慢。</li><li>隔离性强： 由于内存独立，一个进程无法直接访问另一个进程的内存，安全性高。<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><strong>线程是操作系统能够进行运算调度的最小单位，它是进程内的一个执行流（子任务）。一个进程可以包含多个线程。</strong><h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3>充分利用多核CPU进行并行计算（一个进程的多个线程可以在多个核上同时运行），提高程序的响应性（例如将游戏线程分为渲染线程、物理线程、业务逻辑线程来并行加速游戏），更高效地共享进程内资源。<h3 id="关键特性-1"><a href="#关键特性-1" class="headerlink" title="关键特性"></a>关键特性</h3></li><li>共享资源： 同一个进程内的所有线程共享该进程的内存空间（堆、全局变量）和系统资源（如打开的文件）。每个线程有自己的栈和寄存器状态（用于保存执行上下文）。</li><li>轻量级： 创建、销毁、切换线程的开销比进程小很多，因为不需要创建新的地址空间或资源。</li><li>通信开销小： 线程间可以直接读写共享的内存变量进行通信，速度非常快。</li><li>同步复杂： 正因为共享内存，多个线程同时操作共享数据会导致竞争条件。必须使用同步机制（如互斥锁、信号量、条件变量）来保证数据一致性，编程模型更复杂，容易出错（死锁）。</li><li>隔离性弱： 一个线程崩溃（如访问非法地址）通常会导致其所属的整个进程崩溃，因为共享内存空间（部分语言会自带保护机制来避免这种雪崩情况，比如Java）。</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><strong>协程是一种用户态的轻量级线程，其调度完全由用户程序控制（而非操作系统内核）。</strong> 协程运行在线程之上，一个线程内可以运行多个协程。其本质上是一个可以在函数之间主动挂起和恢复的控制流机制，一种异步编程技术。</p><h3 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h3><p>用极低的资源开销实现超高并发，尤其适合 I/O 密集型应用（大部分时间在等待网络、磁盘等操作完成），简化异步编程模型。</p><h3 id="关键特性-2"><a href="#关键特性-2" class="headerlink" title="关键特性"></a>关键特性</h3><ul><li>极轻量级： 创建、销毁、切换协程的开销极小（通常只是保存/恢复少量寄存器，不涉及内核态切换），可以轻松创建成千上万个协程。</li><li>用户态调度： 协程的调度（决定哪个协程运行）由程序员编写的代码（或协程库）在用户空间完成，不依赖操作系统的线程调度器。通常采用协作式调度：一个协程主动让出（yield）执行权，另一个协程才能开始执行。这避免了线程抢占式调度带来的锁竞争开销。</li><li>无同步问题？： 在单线程内运行的多个协程，由于是协作式调度（非抢占），在让出点之间的代码执行是原子的，理论上操作共享数据不需要加锁。但跨线程的协程（不同线程上的协程访问同一数据）或协程与线程混合访问共享数据时，仍然需要同步机制。</li><li>栈空间小： 协程通常有自己独立的栈，但栈空间非常小（可预先分配），且按需增长，内存占用极小。</li><li>高并发： 极低的创建/切换开销和内存占用，使得协程非常适合于需要超高并发（如数万、数十万连接）的 I/O 密集型场景（网络服务器、爬虫等）。</li><li>编程模型： 通常使用 async/await 或显式的 yield 关键字来编写异步代码，逻辑上更接近同步代码，避免了“回调地狱”。</li></ul><h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>想象一家大型流水线集团，集团旗下有许多工厂（进程），线程是工厂里的生产线，协程是生产线上能同时照看多台机器的老师傅。工厂间协作成本高（进程通信），生产线要小心协调（线程同步），老师傅自己就能把协调管理的多台机器（协程调度）。</p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;"        data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;dark-mode&quot;:&quot;light&quot;,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;Electron\&quot; agent=\&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/27.0.9 Chrome/134.0.6998.205 Electron/35.4.0 Safari/537.36\&quot; version=\&quot;27.0.9\&quot;&gt;\n  &lt;diagram id=\&quot;y6z9hWFhSs4X-zh5PFfg\&quot; name=\&quot;Page-1\&quot;&gt;\n    &lt;mxGraphModel dx=\&quot;1072\&quot; dy=\&quot;630\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;850\&quot; pageHeight=\&quot;1100\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;\n      &lt;root&gt;\n        &lt;mxCell id=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;2\&quot; value=\&quot;操作系统\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;align=center;gradientColor=none;fillColor=default;strokeColor=default;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;190\&quot; y=\&quot;200\&quot; width=\&quot;520\&quot; height=\&quot;290\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;3\&quot; value=\&quot;进程\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;210\&quot; y=\&quot;230\&quot; width=\&quot;340\&quot; height=\&quot;240\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;4\&quot; value=\&quot;进程\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;570\&quot; y=\&quot;230\&quot; width=\&quot;50\&quot; height=\&quot;240\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;5\&quot; value=\&quot;.......\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;640\&quot; y=\&quot;230\&quot; width=\&quot;50\&quot; height=\&quot;240\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;6\&quot; value=\&quot;线程\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;230\&quot; y=\&quot;260\&quot; width=\&quot;190\&quot; height=\&quot;140\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;7\&quot; value=\&quot;......\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;490\&quot; y=\&quot;260\&quot; width=\&quot;40\&quot; height=\&quot;140\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;8\&quot; value=\&quot;线程\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;verticalAlign=top;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;435\&quot; y=\&quot;260\&quot; width=\&quot;40\&quot; height=\&quot;140\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;9\&quot; value=\&quot;协程\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;250\&quot; y=\&quot;290\&quot; width=\&quot;40\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;11\&quot; value=\&quot;协程\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;305\&quot; y=\&quot;290\&quot; width=\&quot;40\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;12\&quot; value=\&quot;......\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=default;fontFamily=Helvetica;fillColor=default;gradientColor=none;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;360\&quot; y=\&quot;290\&quot; width=\&quot;40\&quot; height=\&quot;40\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;WJhhEcHRk8HBll8wShTH-12\&quot; value=\&quot;共享内存、资源\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;230\&quot; y=\&quot;420\&quot; width=\&quot;300\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;WJhhEcHRk8HBll8wShTH-13\&quot; value=\&quot;&amp;lt;div style=&amp;quot;overflow: auto; padding: 9.144px 13.716px; text-wrap-mode: wrap; word-break: break-all; font-size: 12.573px; text-align: start; margin-top: 0px !important; margin-bottom: 0px !important;&amp;quot;&amp;gt;栈、寄存器&amp;lt;/div&amp;gt;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;fontFamily=Helvetica;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;250\&quot; y=\&quot;350\&quot; width=\&quot;150\&quot; height=\&quot;30\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n      &lt;/root&gt;\n    &lt;/mxGraphModel&gt;\n  &lt;/diagram&gt;\n&lt;/mxfile&gt;\n&quot;}">    </div><br>    <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script></p><h2 id="对比表"><a href="#对比表" class="headerlink" title="对比表"></a>对比表</h2><div class="table-container"><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>​​资源隔离性​​</td><td>高（独立内存空间，崩溃不影响其他进程）</td><td>中（共享进程内存，线程崩溃可导致进程终止）</td><td>低（共享线程资源，异常仅影响当前协程</td></tr><tr><td>​​创建/销毁开销</td><td>高</td><td>中</td><td>极低</td></tr><tr><td>​​切换开销​</td><td>高（需内核态切换）</td><td>中（需内核调度）</td><td>极低（用户态切换）</td></tr><tr><td>​​通信机制​</td><td>需IPC：管道/共享内存等</td><td>共享内存、同步锁等</td><td>直接调用、Channel</td></tr><tr><td>并发能力</td><td>千数量级</td><td>万数量级</td><td>百万数量级</td></tr></tbody></table></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《操作系统（第四版）》刘振鹏，张明，王煜</li><li><a href="https://segmentfault.com/a/1190000039378412">进程、线程与协程傻傻分不清？一文带你吃透！</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Unity开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 协程 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在博客开始</title>
      <link href="/posts/3862923551/"/>
      <url>/posts/3862923551/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.hdslb.com/bfs/new_dyn/af249322c49879fb5391b9a5aacb427c3127575.jpg" alt=""><br><span id="more"></span></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>小学的时候觉得遗忘这个词很牛逼，很帅。句子里加了遗忘这个词，整体的逼格都不一样了，像是白开水里的一颗红糖。</p><p>遗忘你，遗忘我，遗忘这个世界，太酷了！像是把别人珍视的东西，随手一丢的洒脱。</p><p>所以小学的时候我写作文不会写我忘了什么，而是我遗忘了它。我忘带了作业，庸俗寡淡；我遗忘了作业，高雅！我当时觉得我的作文水平高出了同学一大截，因为我的用词已经领先他们太多了。</p><p>当然现在不会了，现在知道中二是什么意思了，也并不觉得遗忘是什么好事。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>最近发现自己鼓捣的东西，或者看的书，学的知识等东西一段时间不回顾就慢慢腐败消失得差不多了，等需要用到的时候就只剩几根骨头在脑海里，时间再长点，就变成骨粉，长出花。</p><p>当我希望在记忆宫殿里重新找到这部分内容的时候，不知不觉，脑海里就回想起爱音的那句话：</p><p><strong>“ It’s MyGo!!!!! ”</strong></p><p>嗯，确实迷路了，连在哪里看的这部分内容也记不起来了，寄。最后这部分内容就这样滑倒舌尖，然后又被咽下去，像一个大喷嚏，酝酿了好久，姿势都摆好了，但是没有打出来一样。</p><p>遗忘不是一个好事，尤其是遗忘掉我觉得重要的东西的时候。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>知乎里有一个回答： <strong>“当我还是孩子时，我吃过很多食物，现在已经记不起吃过什么了。但可以肯定的是，它们中的一部分已经长成了我的骨头和肉。读书对人的改变也是如此。”</strong>，很长的时间里，我对此深信不疑。</p><p>现在想了想，发现，不太对！我看的一大部分可是专业书，技术书，这部分我想不起来了那不就相当于没有看吗（可达鸭发现了异常.jpg）？</p><p>回过头来看这个回答，发现以前的我不仅会忘记看的书里的内容，还会忘记句子里的一些重要的词语。比如这个阴险的答主藏在角落的，“当我还是孩子”和“一部分”。</p><p>相当长的一段时间，我对这句话的理解是，我看过的书，都长成了我的骨头和肉。现在发现自己遗忘了这句话的定语，应该是一些时间里，看的一些书，会长成我的骨头和肉。像是牛顿运动定律，在近光速条件下几乎完全失效一样，真理是相对的、辩证的。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>有段时间里，我对王阳明的心学额外感兴趣，<strong>“致良知，知行合一”</strong>、<strong>“心即理也，心外无理，心外无物，心外无事”</strong>，看不懂！然后去研究 <strong>《传习录》</strong> ，看完还是不懂！按前面知乎回答的说法，这本书应该属于毒蘑菇之类的食物，不仅消化不了，还把人整得晕乎乎的。</p><p><strong>《传习录》</strong> 我没看懂，不过倒是记住了 <strong>知行合一</strong> 四个字，当然也就记住了这四个字，这四个字的含义我当时并不明白，只是知道白话文应该翻译成知识和行动应该统一。</p><p>后面又看了毛主席的 <strong>《实践论》</strong> ,这才有点明白，知行合一，应该是理论与实践的统一。理论指导实践，实践反作用于理论，螺旋而上的趋向于绝对真理。</p><p>然后我就有点明白怎么才能让书里的内容，长成骨头和肉了。有时候道理就在心里了，但是离真正理解它，还需要自己的实践经验。</p><p>知识和经验之间，隔着一个我。</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>高中的时候，老师不厌其烦的一次又一次和我们说错题本的重要性，有时候还要抽查我们的错题本记录情况。</p><p>我当时一点也不喜欢记错题本，现在也不喜欢。但是迫于老师的淫威，只能装模做样的记录一点。现在我依然觉得这是浪费时间，记了我也不会看，做的题啊，都长成了我的骨肉，对的吧。</p><p>工作后就没有题给我做了，自然也就不存在错题本了。教材也没了，草。知识点啊，被一层又一层包好，放在了互联网的角落里，有时候还是需要付费的，社会险恶啊。</p><p>上学还是挺好的，有人教，有一堆高人写教材，还有一堆人写教材的解析，不会的有人问，而答案是一定有的。</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>尤其在现在这个碎片式阅读盛行的时代，一篇文章的好坏不容易被发现了。论证太长，论据太麻烦，不如直接给出论点并加个感叹号！</p><p><strong>这句话是对的！</strong></p><p>开门见山，酷！山是实心还是空心的，不重要，重要的是有山，读者看见了山。</p><p>逻辑是稀缺的，情感是充沛的。比如我在写内容时，也不会像做数学题一样把推导步骤一步步写完。这样写不好玩，读者大部分也看得头晕。除非这真的和他们利益相关。</p><p>给人以利益的希望也算在内。</p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>以上！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
